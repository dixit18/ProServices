import { classPrivateFieldLooseBase as _classPrivateFieldLooseBase, classPrivateFieldLooseKey as _classPrivateFieldLooseKey } from './_virtual/_rollupPluginBabelHelpers.esm.js';
import { replaceData, noop, timeUntilStale } from './utils.esm.js';
import { notifyManager } from './notifyManager.esm.js';
import { createRetryer, isCancelledError, canFetch } from './retryer.esm.js';
import { Removable } from './removable.esm.js';

// TYPES
var _initialState = /*#__PURE__*/_classPrivateFieldLooseKey("initialState");
var _revertState = /*#__PURE__*/_classPrivateFieldLooseKey("revertState");
var _cache = /*#__PURE__*/_classPrivateFieldLooseKey("cache");
var _promise = /*#__PURE__*/_classPrivateFieldLooseKey("promise");
var _retryer = /*#__PURE__*/_classPrivateFieldLooseKey("retryer");
var _observers = /*#__PURE__*/_classPrivateFieldLooseKey("observers");
var _defaultOptions = /*#__PURE__*/_classPrivateFieldLooseKey("defaultOptions");
var _abortSignalConsumed = /*#__PURE__*/_classPrivateFieldLooseKey("abortSignalConsumed");
var _setOptions = /*#__PURE__*/_classPrivateFieldLooseKey("setOptions");
var _dispatch = /*#__PURE__*/_classPrivateFieldLooseKey("dispatch");
// CLASS

class Query extends Removable {
  constructor(config) {
    super();
    Object.defineProperty(this, _dispatch, {
      value: _dispatch2
    });
    Object.defineProperty(this, _setOptions, {
      value: _setOptions2
    });
    Object.defineProperty(this, _initialState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _revertState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cache, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _promise, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _retryer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _observers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _defaultOptions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _abortSignalConsumed, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _abortSignalConsumed)[_abortSignalConsumed] = false;
    _classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions] = config.defaultOptions;
    _classPrivateFieldLooseBase(this, _setOptions)[_setOptions](config.options);
    _classPrivateFieldLooseBase(this, _observers)[_observers] = [];
    _classPrivateFieldLooseBase(this, _cache)[_cache] = config.cache;
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    _classPrivateFieldLooseBase(this, _initialState)[_initialState] = config.state || getDefaultState(this.options);
    this.state = _classPrivateFieldLooseBase(this, _initialState)[_initialState];
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  optionalRemove() {
    if (!_classPrivateFieldLooseBase(this, _observers)[_observers].length && this.state.fetchStatus === 'idle') {
      _classPrivateFieldLooseBase(this, _cache)[_cache].remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);

    // Set data and mark it as cached
    _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
      data,
      type: 'success',
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
      type: 'setState',
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _classPrivateFieldLoo;
    const promise = _classPrivateFieldLooseBase(this, _promise)[_promise];
    (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _retryer)[_retryer]) == null ? void 0 : _classPrivateFieldLoo.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(_classPrivateFieldLooseBase(this, _initialState)[_initialState]);
  }
  isActive() {
    return _classPrivateFieldLooseBase(this, _observers)[_observers].some(observer => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || _classPrivateFieldLooseBase(this, _observers)[_observers].some(observer => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _classPrivateFieldLoo2;
    const observer = _classPrivateFieldLooseBase(this, _observers)[_observers].find(x => x.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({
      cancelRefetch: false
    });

    // Continue fetch if currently paused
    (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _retryer)[_retryer]) == null ? void 0 : _classPrivateFieldLoo2.continue();
  }
  onOnline() {
    var _classPrivateFieldLoo3;
    const observer = _classPrivateFieldLooseBase(this, _observers)[_observers].find(x => x.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({
      cancelRefetch: false
    });

    // Continue fetch if currently paused
    (_classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _retryer)[_retryer]) == null ? void 0 : _classPrivateFieldLoo3.continue();
  }
  addObserver(observer) {
    if (_classPrivateFieldLooseBase(this, _observers)[_observers].indexOf(observer) === -1) {
      _classPrivateFieldLooseBase(this, _observers)[_observers].push(observer);

      // Stop the query from being garbage collected
      this.clearGcTimeout();
      _classPrivateFieldLooseBase(this, _cache)[_cache].notify({
        type: 'observerAdded',
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (_classPrivateFieldLooseBase(this, _observers)[_observers].indexOf(observer) !== -1) {
      _classPrivateFieldLooseBase(this, _observers)[_observers] = _classPrivateFieldLooseBase(this, _observers)[_observers].filter(x => x !== observer);
      if (!_classPrivateFieldLooseBase(this, _observers)[_observers].length) {
        // If the transport layer does not support cancellation
        // we'll let the query continue so the result can be cached
        if (_classPrivateFieldLooseBase(this, _retryer)[_retryer]) {
          if (_classPrivateFieldLooseBase(this, _abortSignalConsumed)[_abortSignalConsumed]) {
            _classPrivateFieldLooseBase(this, _retryer)[_retryer].cancel({
              revert: true
            });
          } else {
            _classPrivateFieldLooseBase(this, _retryer)[_retryer].cancelRetry();
          }
        }
        this.scheduleGc();
      }
      _classPrivateFieldLooseBase(this, _cache)[_cache].notify({
        type: 'observerRemoved',
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return _classPrivateFieldLooseBase(this, _observers)[_observers].length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
        type: 'invalidate'
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== 'idle') {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        // Silently cancel current fetch if the user wants to cancel refetches
        this.cancel({
          silent: true
        });
      } else if (_classPrivateFieldLooseBase(this, _promise)[_promise]) {
        var _classPrivateFieldLoo4;
        // make sure that retries that were potentially cancelled due to unmounts can continue
        (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _retryer)[_retryer]) == null ? void 0 : _classPrivateFieldLoo4.continueRetry();
        // Return current promise if we are already fetching
        return _classPrivateFieldLooseBase(this, _promise)[_promise];
      }
    }

    // Update config if passed, otherwise the config from the last execution is used
    if (options) {
      _classPrivateFieldLooseBase(this, _setOptions)[_setOptions](options);
    }

    // Use the options from the first observer with a query function if no function is found.
    // This can happen when the query is hydrated or created with setQueryData.
    if (!this.options.queryFn) {
      const observer = _classPrivateFieldLooseBase(this, _observers)[_observers].find(x => x.options.queryFn);
      if (observer) {
        _classPrivateFieldLooseBase(this, _setOptions)[_setOptions](observer.options);
      }
    }
    if (process.env.NODE_ENV !== 'production') {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);
      }
    }
    const abortController = new AbortController();

    // Create query function context
    const queryFnContext = {
      queryKey: this.queryKey,
      meta: this.meta
    };

    // Adds an enumerable signal property to the object that
    // which sets abortSignalConsumed to true when the signal
    // is read.
    const addSignalProperty = object => {
      Object.defineProperty(object, 'signal', {
        enumerable: true,
        get: () => {
          _classPrivateFieldLooseBase(this, _abortSignalConsumed)[_abortSignalConsumed] = true;
          return abortController.signal;
        }
      });
    };
    addSignalProperty(queryFnContext);

    // Create fetch function
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject(new Error('Missing queryFn'));
      }
      _classPrivateFieldLooseBase(this, _abortSignalConsumed)[_abortSignalConsumed] = false;
      return this.options.queryFn(queryFnContext);
    };

    // Trigger behavior hook
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);

    // Store state in case the current fetch needs to be reverted
    _classPrivateFieldLooseBase(this, _revertState)[_revertState] = this.state;

    // Set to fetching state if not already in it
    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
        type: 'fetch',
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = error => {
      // Optimistically update state if needed
      if (!(isCancelledError(error) && error.silent)) {
        _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'error',
          error: error
        });
      }
      if (!isCancelledError(error)) {
        var _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;
        // Notify cache callback
        (_classPrivateFieldLoo5 = (_classPrivateFieldLoo6 = _classPrivateFieldLooseBase(this, _cache)[_cache].config).onError) == null ? void 0 : _classPrivateFieldLoo5.call(_classPrivateFieldLoo6, error, this);
        (_classPrivateFieldLoo7 = (_classPrivateFieldLoo8 = _classPrivateFieldLooseBase(this, _cache)[_cache].config).onSettled) == null ? void 0 : _classPrivateFieldLoo7.call(_classPrivateFieldLoo8, this.state.data, error, this);
      }
      if (!this.isFetchingOptimistic) {
        // Schedule query gc after fetching
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };

    // Try to fetch the data
    _classPrivateFieldLooseBase(this, _retryer)[_retryer] = createRetryer({
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: data => {
        var _classPrivateFieldLoo9, _classPrivateFieldLoo10, _classPrivateFieldLoo11, _classPrivateFieldLoo12;
        if (typeof data === 'undefined') {
          if (process.env.NODE_ENV !== 'production') {
            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);
          }
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        this.setData(data);

        // Notify cache callback
        (_classPrivateFieldLoo9 = (_classPrivateFieldLoo10 = _classPrivateFieldLooseBase(this, _cache)[_cache].config).onSuccess) == null ? void 0 : _classPrivateFieldLoo9.call(_classPrivateFieldLoo10, data, this);
        (_classPrivateFieldLoo11 = (_classPrivateFieldLoo12 = _classPrivateFieldLooseBase(this, _cache)[_cache].config).onSettled) == null ? void 0 : _classPrivateFieldLoo11.call(_classPrivateFieldLoo12, data, this.state.error, this);
        if (!this.isFetchingOptimistic) {
          // Schedule query gc after fetching
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'failed',
          failureCount,
          error
        });
      },
      onPause: () => {
        _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'pause'
        });
      },
      onContinue: () => {
        _classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'continue'
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    _classPrivateFieldLooseBase(this, _promise)[_promise] = _classPrivateFieldLooseBase(this, _retryer)[_retryer].promise;
    return _classPrivateFieldLooseBase(this, _promise)[_promise];
  }
}
function _setOptions2(options) {
  this.options = {
    ..._classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions],
    ...options
  };
  this.updateGcTime(this.options.gcTime);
}
function _dispatch2(action) {
  const reducer = state => {
    var _action$meta, _action$dataUpdatedAt;
    switch (action.type) {
      case 'failed':
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case 'pause':
        return {
          ...state,
          fetchStatus: 'paused'
        };
      case 'continue':
        return {
          ...state,
          fetchStatus: 'fetching'
        };
      case 'fetch':
        return {
          ...state,
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
          fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',
          ...(!state.dataUpdatedAt && {
            error: null,
            status: 'pending'
          })
        };
      case 'success':
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
          error: null,
          isInvalidated: false,
          status: 'success',
          ...(!action.manual && {
            fetchStatus: 'idle',
            fetchFailureCount: 0,
            fetchFailureReason: null
          })
        };
      case 'error':
        const error = action.error;
        if (isCancelledError(error) && error.revert && _classPrivateFieldLooseBase(this, _revertState)[_revertState]) {
          return {
            ..._classPrivateFieldLooseBase(this, _revertState)[_revertState]
          };
        }
        return {
          ...state,
          error: error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: 'idle',
          status: 'error'
        };
      case 'invalidate':
        return {
          ...state,
          isInvalidated: true
        };
      case 'setState':
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    _classPrivateFieldLooseBase(this, _observers)[_observers].forEach(observer => {
      observer.onQueryUpdate();
    });
    _classPrivateFieldLooseBase(this, _cache)[_cache].notify({
      query: this,
      type: 'updated',
      action
    });
  });
}
function getDefaultState(options) {
  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;
  const hasData = typeof data !== 'undefined';
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? 'success' : 'pending',
    fetchStatus: 'idle'
  };
}

export { Query };
//# sourceMappingURL=query.esm.js.map
