'use strict';

var utils = require('./utils.js');

function infiniteQueryBehavior() {
  return {
    onFetch: context => {
      context.fetchFn = async () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$state$data, _context$state$data2;
        const options = context.options;
        const direction = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : (_context$fetchOptions3 = _context$fetchOptions2.fetchMore) == null ? void 0 : _context$fetchOptions3.direction;
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        const empty = {
          pages: [],
          pageParams: []
        };
        let cancelled = false;
        const addSignalProperty = object => {
          Object.defineProperty(object, 'signal', {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener('abort', () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };

        // Get query function
        const queryFn = context.options.queryFn || (() => Promise.reject(new Error('Missing queryFn')));

        // Create function to fetch a page
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (typeof param === 'undefined' && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? 'backward' : 'forward',
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(queryFnContext);
          const {
            maxPages
          } = context.options;
          const addTo = previous ? utils.addToStart : utils.addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        let result;

        // Fetch first page?
        if (!oldPages.length) {
          result = await fetchPage(empty, options.defaultPageParam);
        }

        // fetch next / previous page?
        else if (direction) {
          const previous = direction === 'backward';
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        }

        // Refetch pages
        else {
          // Fetch first page
          result = await fetchPage(empty, oldPageParams[0]);

          // Fetch remaining pages
          for (let i = 1; i < oldPages.length; i++) {
            const param = getNextPageParam(options, result);
            result = await fetchPage(result, param);
          }
        }
        return result;
      };
    }
  };
}
function getNextPageParam(options, {
  pages,
  pageParams
}) {
  const lastIndex = pages.length - 1;
  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);
}
function getPreviousPageParam(options, {
  pages,
  pageParams
}) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages, pageParams[0], pageParams);
}

/**
 * Checks if there is a next page.
 */
function hasNextPage(options, data) {
  if (!data) return false;
  return typeof getNextPageParam(options, data) !== 'undefined';
}

/**
 * Checks if there is a previous page.
 */
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam) return false;
  return typeof getPreviousPageParam(options, data) !== 'undefined';
}

exports.hasNextPage = hasNextPage;
exports.hasPreviousPage = hasPreviousPage;
exports.infiniteQueryBehavior = infiniteQueryBehavior;
//# sourceMappingURL=infiniteQueryBehavior.js.map
