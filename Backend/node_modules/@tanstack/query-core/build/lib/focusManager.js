'use strict';

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var subscribable = require('./subscribable.js');
var utils = require('./utils.js');

var _focused = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("focused");
var _cleanup = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("cleanup");
var _setup = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("setup");
class FocusManager extends subscribable.Subscribable {
  constructor() {
    super();
    Object.defineProperty(this, _focused, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cleanup, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _setup, {
      writable: true,
      value: void 0
    });
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _setup)[_setup] = onFocus => {
      // addEventListener does not exist in React Native, but window does
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (!utils.isServer && window.addEventListener) {
        const listener = () => onFocus();
        // Listen to visibilitychange
        window.addEventListener('visibilitychange', listener, false);
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!_rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _cleanup)[_cleanup]) {
      this.setEventListener(_rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _setup)[_setup]);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _classPrivateFieldLoo, _classPrivateFieldLoo2;
      (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _cleanup))[_cleanup]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2);
      _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _cleanup)[_cleanup] = undefined;
    }
  }
  setEventListener(setup) {
    var _classPrivateFieldLoo3, _classPrivateFieldLoo4;
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _setup)[_setup] = setup;
    (_classPrivateFieldLoo3 = (_classPrivateFieldLoo4 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _cleanup))[_cleanup]) == null ? void 0 : _classPrivateFieldLoo3.call(_classPrivateFieldLoo4);
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _cleanup)[_cleanup] = setup(focused => {
      if (typeof focused === 'boolean') {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _focused)[_focused] = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach(listener => {
      listener();
    });
  }
  isFocused() {
    var _globalThis$document;
    if (typeof _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _focused)[_focused] === 'boolean') {
      return _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _focused)[_focused];
    }

    // document global can be unavailable in react native
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return ((_globalThis$document = globalThis.document) == null ? void 0 : _globalThis$document.visibilityState) !== 'hidden';
  }
}
const focusManager = new FocusManager();

exports.FocusManager = FocusManager;
exports.focusManager = focusManager;
//# sourceMappingURL=focusManager.js.map
