import { classPrivateFieldLooseBase as _classPrivateFieldLooseBase, classPrivateFieldLooseKey as _classPrivateFieldLooseKey } from './_virtual/_rollupPluginBabelHelpers.esm.js';
import { notifyManager } from './notifyManager.esm.js';
import { Mutation } from './mutation.esm.js';
import { matchMutation, noop } from './utils.esm.js';
import { Subscribable } from './subscribable.esm.js';

// TYPES
var _mutations = /*#__PURE__*/_classPrivateFieldLooseKey("mutations");
var _mutationId = /*#__PURE__*/_classPrivateFieldLooseKey("mutationId");
var _resuming = /*#__PURE__*/_classPrivateFieldLooseKey("resuming");
// CLASS

class MutationCache extends Subscribable {
  constructor(config = {}) {
    super();
    Object.defineProperty(this, _mutations, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mutationId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resuming, {
      writable: true,
      value: void 0
    });
    this.config = config;
    _classPrivateFieldLooseBase(this, _mutations)[_mutations] = [];
    _classPrivateFieldLooseBase(this, _mutationId)[_mutationId] = 0;
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++_classPrivateFieldLooseBase(this, _mutationId)[_mutationId],
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    _classPrivateFieldLooseBase(this, _mutations)[_mutations].push(mutation);
    this.notify({
      type: 'added',
      mutation
    });
  }
  remove(mutation) {
    _classPrivateFieldLooseBase(this, _mutations)[_mutations] = _classPrivateFieldLooseBase(this, _mutations)[_mutations].filter(x => x !== mutation);
    this.notify({
      type: 'removed',
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      _classPrivateFieldLooseBase(this, _mutations)[_mutations].forEach(mutation => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return _classPrivateFieldLooseBase(this, _mutations)[_mutations];
  }
  find(filters) {
    const defaultedFilters = {
      exact: true,
      ...filters
    };
    return _classPrivateFieldLooseBase(this, _mutations)[_mutations].find(mutation => matchMutation(defaultedFilters, mutation));
  }
  findAll(filters = {}) {
    return _classPrivateFieldLooseBase(this, _mutations)[_mutations].filter(mutation => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(listener => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    var _classPrivateFieldLoo;
    _classPrivateFieldLooseBase(this, _resuming)[_resuming] = ((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _resuming)[_resuming]) != null ? _classPrivateFieldLoo : Promise.resolve()).then(() => {
      const pausedMutations = _classPrivateFieldLooseBase(this, _mutations)[_mutations].filter(x => x.state.isPaused);
      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
    }).then(() => {
      _classPrivateFieldLooseBase(this, _resuming)[_resuming] = undefined;
    });
    return _classPrivateFieldLooseBase(this, _resuming)[_resuming];
  }
}

export { MutationCache };
//# sourceMappingURL=mutationCache.esm.js.map
