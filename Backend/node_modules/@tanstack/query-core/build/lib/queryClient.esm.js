import { classPrivateFieldLooseBase as _classPrivateFieldLooseBase, classPrivateFieldLooseKey as _classPrivateFieldLooseKey } from './_virtual/_rollupPluginBabelHelpers.esm.js';
import { functionalUpdate, noop, hashKey, partialMatchKey, hashQueryKeyByOptions } from './utils.esm.js';
import { QueryCache } from './queryCache.esm.js';
import { MutationCache } from './mutationCache.esm.js';
import { focusManager } from './focusManager.esm.js';
import { onlineManager } from './onlineManager.esm.js';
import { notifyManager } from './notifyManager.esm.js';
import { infiniteQueryBehavior } from './infiniteQueryBehavior.esm.js';

// TYPES
var _queryCache = /*#__PURE__*/_classPrivateFieldLooseKey("queryCache");
var _mutationCache = /*#__PURE__*/_classPrivateFieldLooseKey("mutationCache");
var _defaultOptions = /*#__PURE__*/_classPrivateFieldLooseKey("defaultOptions");
var _queryDefaults = /*#__PURE__*/_classPrivateFieldLooseKey("queryDefaults");
var _mutationDefaults = /*#__PURE__*/_classPrivateFieldLooseKey("mutationDefaults");
var _mountCount = /*#__PURE__*/_classPrivateFieldLooseKey("mountCount");
var _unsubscribeFocus = /*#__PURE__*/_classPrivateFieldLooseKey("unsubscribeFocus");
var _unsubscribeOnline = /*#__PURE__*/_classPrivateFieldLooseKey("unsubscribeOnline");
// CLASS

class QueryClient {
  constructor(config = {}) {
    Object.defineProperty(this, _queryCache, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mutationCache, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _defaultOptions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _queryDefaults, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mutationDefaults, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mountCount, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _unsubscribeFocus, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _unsubscribeOnline, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _queryCache)[_queryCache] = config.queryCache || new QueryCache();
    _classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache] = config.mutationCache || new MutationCache();
    _classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions] = config.defaultOptions || {};
    _classPrivateFieldLooseBase(this, _queryDefaults)[_queryDefaults] = new Map();
    _classPrivateFieldLooseBase(this, _mutationDefaults)[_mutationDefaults] = new Map();
    _classPrivateFieldLooseBase(this, _mountCount)[_mountCount] = 0;
  }
  mount() {
    _classPrivateFieldLooseBase(this, _mountCount)[_mountCount]++;
    if (_classPrivateFieldLooseBase(this, _mountCount)[_mountCount] !== 1) return;
    _classPrivateFieldLooseBase(this, _unsubscribeFocus)[_unsubscribeFocus] = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].onFocus();
      }
    });
    _classPrivateFieldLooseBase(this, _unsubscribeOnline)[_unsubscribeOnline] = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].onOnline();
      }
    });
  }
  unmount() {
    var _classPrivateFieldLoo, _classPrivateFieldLoo2, _classPrivateFieldLoo3, _classPrivateFieldLoo4;
    _classPrivateFieldLooseBase(this, _mountCount)[_mountCount]--;
    if (_classPrivateFieldLooseBase(this, _mountCount)[_mountCount] !== 0) return;
    (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _unsubscribeFocus))[_unsubscribeFocus]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2);
    _classPrivateFieldLooseBase(this, _unsubscribeFocus)[_unsubscribeFocus] = undefined;
    (_classPrivateFieldLoo3 = (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _unsubscribeOnline))[_unsubscribeOnline]) == null ? void 0 : _classPrivateFieldLoo3.call(_classPrivateFieldLoo4);
    _classPrivateFieldLooseBase(this, _unsubscribeOnline)[_unsubscribeOnline] = undefined;
  }
  isFetching(filters) {
    return _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].findAll({
      ...filters,
      fetchStatus: 'fetching'
    }).length;
  }
  isMutating(filters) {
    return _classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].findAll({
      ...filters,
      status: 'pending'
    }).length;
  }
  getQueryData(queryKey) {
    var _classPrivateFieldLoo5;
    return (_classPrivateFieldLoo5 = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].find({
      queryKey
    })) == null ? void 0 : _classPrivateFieldLoo5.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(options);
  }
  getQueriesData(filters) {
    return this.getQueryCache().findAll(filters).map(({
      queryKey,
      state
    }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const query = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].find({
      queryKey
    });
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === 'undefined') {
      return undefined;
    }
    const defaultedOptions = this.defaultQueryOptions({
      queryKey
    });
    return _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true
    });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(filters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
  }
  getQueryState(queryKey) {
    var _classPrivateFieldLoo6;
    return (_classPrivateFieldLoo6 = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].find({
      queryKey
    })) == null ? void 0 : _classPrivateFieldLoo6.state;
  }
  removeQueries(filters) {
    const queryCache = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache];
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach(query => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache];
    const refetchFilters = {
      type: 'active',
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach(query => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = {
      revert: true,
      ...cancelOptions
    };
    const promises = notifyManager.batch(() => _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].findAll(filters).map(query => query.cancel(defaultedCancelOptions)));
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].findAll(filters).forEach(query => {
        query.invalidate();
      });
      if (filters.refetchType === 'none') {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    var _options$cancelRefetc;
    const fetchOptions = {
      ...options,
      cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true
    };
    const promises = notifyManager.batch(() => _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].findAll(filters).filter(query => !query.isDisabled()).map(query => {
      let promise = query.fetch(undefined, fetchOptions);
      if (!fetchOptions.throwOnError) {
        promise = promise.catch(noop);
      }
      return query.state.fetchStatus === 'paused' ? Promise.resolve() : promise;
    }));
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);

    // https://github.com/tannerlinsley/react-query/issues/652
    if (typeof defaultedOptions.retry === 'undefined') {
      defaultedOptions.retry = false;
    }
    const query = _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior();
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  resumePausedMutations() {
    return _classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].resumePausedMutations();
  }
  getQueryCache() {
    return _classPrivateFieldLooseBase(this, _queryCache)[_queryCache];
  }
  getMutationCache() {
    return _classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache];
  }
  getDefaultOptions() {
    return _classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions];
  }
  setDefaultOptions(options) {
    _classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions] = options;
  }
  setQueryDefaults(queryKey, options) {
    _classPrivateFieldLooseBase(this, _queryDefaults)[_queryDefaults].set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [..._classPrivateFieldLooseBase(this, _queryDefaults)[_queryDefaults].values()];
    let result = {};
    defaults.forEach(queryDefault => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = {
          ...result,
          ...queryDefault.defaultOptions
        };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    _classPrivateFieldLooseBase(this, _mutationDefaults)[_mutationDefaults].set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [..._classPrivateFieldLooseBase(this, _mutationDefaults)[_mutationDefaults].values()];
    let result = {};
    defaults.forEach(queryDefault => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = {
          ...result,
          ...queryDefault.defaultOptions
        };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ..._classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions].queries,
      ...((options == null ? void 0 : options.queryKey) && this.getQueryDefaults(options.queryKey)),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }

    // dependent default values
    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';
    }
    if (typeof defaultedOptions.throwOnError === 'undefined') {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ..._classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions].mutations,
      ...((options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey)),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    _classPrivateFieldLooseBase(this, _queryCache)[_queryCache].clear();
    _classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].clear();
  }
}

export { QueryClient };
//# sourceMappingURL=queryClient.esm.js.map
