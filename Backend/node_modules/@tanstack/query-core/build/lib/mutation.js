'use strict';

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var notifyManager = require('./notifyManager.js');
var removable = require('./removable.js');
var retryer = require('./retryer.js');

// TYPES
var _observers = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("observers");
var _defaultOptions = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("defaultOptions");
var _mutationCache = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("mutationCache");
var _retryer = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("retryer");
var _dispatch = /*#__PURE__*/_rollupPluginBabelHelpers.classPrivateFieldLooseKey("dispatch");
// CLASS

class Mutation extends removable.Removable {
  constructor(config) {
    super();
    Object.defineProperty(this, _dispatch, {
      value: _dispatch2
    });
    Object.defineProperty(this, _observers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _defaultOptions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mutationCache, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _retryer, {
      writable: true,
      value: void 0
    });
    this.mutationId = config.mutationId;
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions] = config.defaultOptions;
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache] = config.mutationCache;
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers] = [];
    this.state = config.state || getDefaultState();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = {
      ..._rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _defaultOptions)[_defaultOptions],
      ...options
    };
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (_rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers].indexOf(observer) === -1) {
      _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers].push(observer);

      // Stop the mutation from being garbage collected
      this.clearGcTimeout();
      _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].notify({
        type: 'observerAdded',
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers] = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers].filter(x => x !== observer);
    this.scheduleGc();
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].notify({
      type: 'observerRemoved',
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!_rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers].length) {
      if (this.state.status === 'pending') {
        this.scheduleGc();
      } else {
        _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].remove(this);
      }
    }
  }
  continue() {
    var _classPrivateFieldLoo, _classPrivateFieldLoo2;
    return (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _retryer)[_retryer]) == null ? void 0 : _classPrivateFieldLoo2.continue()) != null ? _classPrivateFieldLoo :
    // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const executeMutation = () => {
      var _this$options$retry;
      _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _retryer)[_retryer] = retryer.createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject(new Error('No mutationFn found'));
          }
          return this.options.mutationFn(variables);
        },
        onFail: (failureCount, error) => {
          _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
            type: 'failed',
            failureCount,
            error
          });
        },
        onPause: () => {
          _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
            type: 'pause'
          });
        },
        onContinue: () => {
          _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
            type: 'continue'
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _retryer)[_retryer].promise;
    };
    const restored = this.state.status === 'pending';
    try {
      var _classPrivateFieldLoo5, _classPrivateFieldLoo6, _this$options$onSucce, _this$options2, _classPrivateFieldLoo7, _classPrivateFieldLoo8, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _classPrivateFieldLoo3, _classPrivateFieldLoo4, _this$options$onMutat, _this$options;
        _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'pending',
          variables
        });
        // Notify cache callback
        await ((_classPrivateFieldLoo3 = (_classPrivateFieldLoo4 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].config).onMutate) == null ? void 0 : _classPrivateFieldLoo3.call(_classPrivateFieldLoo4, variables, this));
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, variables));
        if (context !== this.state.context) {
          _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
            type: 'pending',
            context,
            variables
          });
        }
      }
      const data = await executeMutation();

      // Notify cache callback
      await ((_classPrivateFieldLoo5 = (_classPrivateFieldLoo6 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].config).onSuccess) == null ? void 0 : _classPrivateFieldLoo5.call(_classPrivateFieldLoo6, data, variables, this.state.context, this));
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, variables, this.state.context));

      // Notify cache callback
      await ((_classPrivateFieldLoo7 = (_classPrivateFieldLoo8 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].config).onSettled) == null ? void 0 : _classPrivateFieldLoo7.call(_classPrivateFieldLoo8, data, null, this.state.variables, this.state.context, this));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, variables, this.state.context));
      _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
        type: 'success',
        data
      });
      return data;
    } catch (error) {
      try {
        var _classPrivateFieldLoo9, _classPrivateFieldLoo10, _this$options$onError, _this$options4, _classPrivateFieldLoo11, _classPrivateFieldLoo12, _this$options$onSettl2, _this$options5;
        // Notify cache callback
        await ((_classPrivateFieldLoo9 = (_classPrivateFieldLoo10 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].config).onError) == null ? void 0 : _classPrivateFieldLoo9.call(_classPrivateFieldLoo10, error, variables, this.state.context, this));
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, variables, this.state.context));

        // Notify cache callback
        await ((_classPrivateFieldLoo11 = (_classPrivateFieldLoo12 = _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].config).onSettled) == null ? void 0 : _classPrivateFieldLoo11.call(_classPrivateFieldLoo12, undefined, error, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, variables, this.state.context));
        throw error;
      } finally {
        _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _dispatch)[_dispatch]({
          type: 'error',
          error: error
        });
      }
    }
  }
}
function _dispatch2(action) {
  const reducer = state => {
    switch (action.type) {
      case 'failed':
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case 'pause':
        return {
          ...state,
          isPaused: true
        };
      case 'continue':
        return {
          ...state,
          isPaused: false
        };
      case 'pending':
        return {
          ...state,
          context: action.context,
          data: undefined,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: !retryer.canFetch(this.options.networkMode),
          status: 'pending',
          variables: action.variables,
          submittedAt: Date.now()
        };
      case 'success':
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: 'success',
          isPaused: false
        };
      case 'error':
        return {
          ...state,
          data: undefined,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: 'error'
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.notifyManager.batch(() => {
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _observers)[_observers].forEach(observer => {
      observer.onMutationUpdate(action);
    });
    _rollupPluginBabelHelpers.classPrivateFieldLooseBase(this, _mutationCache)[_mutationCache].notify({
      mutation: this,
      type: 'updated',
      action
    });
  });
}
function getDefaultState() {
  return {
    context: undefined,
    data: undefined,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: 'idle',
    variables: undefined,
    submittedAt: 0
  };
}

exports.Mutation = Mutation;
exports.getDefaultState = getDefaultState;
//# sourceMappingURL=mutation.js.map
