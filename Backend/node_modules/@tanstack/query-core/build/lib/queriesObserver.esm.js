import { classPrivateFieldLooseBase as _classPrivateFieldLooseBase, classPrivateFieldLooseKey as _classPrivateFieldLooseKey } from './_virtual/_rollupPluginBabelHelpers.esm.js';
import { notifyManager } from './notifyManager.esm.js';
import { QueryObserver } from './queryObserver.esm.js';
import { Subscribable } from './subscribable.esm.js';
import { replaceEqualDeep } from './utils.esm.js';

function difference(array1, array2) {
  return array1.filter(x => array2.indexOf(x) === -1);
}
function replaceAt(array, index, value) {
  const copy = array.slice(0);
  copy[index] = value;
  return copy;
}
var _client = /*#__PURE__*/_classPrivateFieldLooseKey("client");
var _result = /*#__PURE__*/_classPrivateFieldLooseKey("result");
var _queries = /*#__PURE__*/_classPrivateFieldLooseKey("queries");
var _observers = /*#__PURE__*/_classPrivateFieldLooseKey("observers");
var _options = /*#__PURE__*/_classPrivateFieldLooseKey("options");
var _combinedResult = /*#__PURE__*/_classPrivateFieldLooseKey("combinedResult");
var _setResult = /*#__PURE__*/_classPrivateFieldLooseKey("setResult");
var _combineResult = /*#__PURE__*/_classPrivateFieldLooseKey("combineResult");
var _findMatchingObservers = /*#__PURE__*/_classPrivateFieldLooseKey("findMatchingObservers");
var _onUpdate = /*#__PURE__*/_classPrivateFieldLooseKey("onUpdate");
var _notify = /*#__PURE__*/_classPrivateFieldLooseKey("notify");
class QueriesObserver extends Subscribable {
  constructor(client, _queries2, _options2) {
    super();
    Object.defineProperty(this, _notify, {
      value: _notify2
    });
    Object.defineProperty(this, _onUpdate, {
      value: _onUpdate2
    });
    Object.defineProperty(this, _findMatchingObservers, {
      value: _findMatchingObservers2
    });
    Object.defineProperty(this, _combineResult, {
      value: _combineResult2
    });
    Object.defineProperty(this, _setResult, {
      value: _setResult2
    });
    Object.defineProperty(this, _client, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _result, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _queries, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _observers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _options, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _combinedResult, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _client)[_client] = client;
    _classPrivateFieldLooseBase(this, _queries)[_queries] = [];
    _classPrivateFieldLooseBase(this, _observers)[_observers] = [];
    _classPrivateFieldLooseBase(this, _setResult)[_setResult]([]);
    this.setQueries(_queries2, _options2);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      _classPrivateFieldLooseBase(this, _observers)[_observers].forEach(observer => {
        observer.subscribe(result => {
          _classPrivateFieldLooseBase(this, _onUpdate)[_onUpdate](observer, result);
        });
      });
    }
  }
  onUnsubscribe() {
    if (!this.listeners.size) {
      this.destroy();
    }
  }
  destroy() {
    this.listeners = new Set();
    _classPrivateFieldLooseBase(this, _observers)[_observers].forEach(observer => {
      observer.destroy();
    });
  }
  setQueries(queries, options, notifyOptions) {
    _classPrivateFieldLooseBase(this, _queries)[_queries] = queries;
    _classPrivateFieldLooseBase(this, _options)[_options] = options;
    notifyManager.batch(() => {
      const prevObservers = _classPrivateFieldLooseBase(this, _observers)[_observers];
      const newObserverMatches = _classPrivateFieldLooseBase(this, _findMatchingObservers)[_findMatchingObservers](_classPrivateFieldLooseBase(this, _queries)[_queries]);

      // set options for the new observers to notify of changes
      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));
      const newObservers = newObserverMatches.map(match => match.observer);
      const newResult = newObservers.map(observer => observer.getCurrentResult());
      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);
      if (prevObservers.length === newObservers.length && !hasIndexChange) {
        return;
      }
      _classPrivateFieldLooseBase(this, _observers)[_observers] = newObservers;
      _classPrivateFieldLooseBase(this, _setResult)[_setResult](newResult);
      if (!this.hasListeners()) {
        return;
      }
      difference(prevObservers, newObservers).forEach(observer => {
        observer.destroy();
      });
      difference(newObservers, prevObservers).forEach(observer => {
        observer.subscribe(result => {
          _classPrivateFieldLooseBase(this, _onUpdate)[_onUpdate](observer, result);
        });
      });
      _classPrivateFieldLooseBase(this, _notify)[_notify]();
    });
  }
  getCurrentResult() {
    return _classPrivateFieldLooseBase(this, _combinedResult)[_combinedResult];
  }
  getQueries() {
    return _classPrivateFieldLooseBase(this, _observers)[_observers].map(observer => observer.getCurrentQuery());
  }
  getObservers() {
    return _classPrivateFieldLooseBase(this, _observers)[_observers];
  }
  getOptimisticResult(queries) {
    const matches = _classPrivateFieldLooseBase(this, _findMatchingObservers)[_findMatchingObservers](queries);
    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));
    return [result, r => {
      return _classPrivateFieldLooseBase(this, _combineResult)[_combineResult](r != null ? r : result);
    }, () => {
      return matches.map((match, index) => {
        const observerResult = result[index];
        return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult) : observerResult;
      });
    }];
  }
}
function _setResult2(value) {
  _classPrivateFieldLooseBase(this, _result)[_result] = value;
  _classPrivateFieldLooseBase(this, _combinedResult)[_combinedResult] = _classPrivateFieldLooseBase(this, _combineResult)[_combineResult](value);
}
function _combineResult2(input) {
  var _classPrivateFieldLoo;
  const combine = (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _options)[_options]) == null ? void 0 : _classPrivateFieldLoo.combine;
  if (combine) {
    return replaceEqualDeep(_classPrivateFieldLooseBase(this, _combinedResult)[_combinedResult], combine(input));
  }
  return input;
}
function _findMatchingObservers2(queries) {
  const prevObservers = _classPrivateFieldLooseBase(this, _observers)[_observers];
  const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));
  const defaultedQueryOptions = queries.map(options => _classPrivateFieldLooseBase(this, _client)[_client].defaultQueryOptions(options));
  const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {
    const match = prevObserversMap.get(defaultedOptions.queryHash);
    if (match != null) {
      return [{
        defaultedQueryOptions: defaultedOptions,
        observer: match
      }];
    }
    return [];
  });
  const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));
  const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));
  const getObserver = options => {
    const defaultedOptions = _classPrivateFieldLooseBase(this, _client)[_client].defaultQueryOptions(options);
    const currentObserver = _classPrivateFieldLooseBase(this, _observers)[_observers].find(o => o.options.queryHash === defaultedOptions.queryHash);
    return currentObserver != null ? currentObserver : new QueryObserver(_classPrivateFieldLooseBase(this, _client)[_client], defaultedOptions);
  };
  const newOrReusedObservers = unmatchedQueries.map(options => {
    return {
      defaultedQueryOptions: options,
      observer: getObserver(options)
    };
  });
  const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);
  return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
}
function _onUpdate2(observer, result) {
  const index = _classPrivateFieldLooseBase(this, _observers)[_observers].indexOf(observer);
  if (index !== -1) {
    _classPrivateFieldLooseBase(this, _setResult)[_setResult](replaceAt(_classPrivateFieldLooseBase(this, _result)[_result], index, result));
    _classPrivateFieldLooseBase(this, _notify)[_notify]();
  }
}
function _notify2() {
  notifyManager.batch(() => {
    this.listeners.forEach(listener => {
      listener(_classPrivateFieldLooseBase(this, _result)[_result]);
    });
  });
}

export { QueriesObserver };
//# sourceMappingURL=queriesObserver.esm.js.map
