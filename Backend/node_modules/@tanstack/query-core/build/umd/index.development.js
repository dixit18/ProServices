(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.QueryCore = {}));
})(this, (function (exports) { 'use strict';

  class Subscribable {
    constructor() {
      this.listeners = new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      this.listeners.add(listener);
      this.onSubscribe();
      return () => {
        this.listeners.delete(listener);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
      // Do nothing
    }
    onUnsubscribe() {
      // Do nothing
    }
  }

  // TYPES

  // UTILS

  const isServer = typeof window === 'undefined' || 'Deno' in window;
  function noop() {
    return undefined;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === 'number' && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function matchQuery(filters, query) {
    const {
      type = 'all',
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (queryKey) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== 'all') {
      const isActive = query.isActive();
      if (type === 'active' && !isActive) {
        return false;
      }
      if (type === 'inactive' && isActive) {
        return false;
      }
    }
    if (typeof stale === 'boolean' && query.isStale() !== stale) {
      return false;
    }
    if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const {
      exact,
      status,
      predicate,
      mutationKey
    } = filters;
    if (mutationKey) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (status && mutation.state.status !== status) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options) {
    const hashFn = options?.queryKeyHashFn || hashKey;
    return hashFn(queryKey);
  }

  /**
   * Default query & mutation keys hash function.
   * Hashes the value into a stable hash.
   */
  function hashKey(queryKey) {
    return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val);
  }

  /**
   * Checks if key `b` partially matches with key `a`.
   */

  function partialMatchKey(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
      return !Object.keys(b).some(key => !partialMatchKey(a[key], b[key]));
    }
    return false;
  }

  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */

  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }
    const array = isPlainArray(a) && isPlainArray(b);
    if (array || isPlainObject(a) && isPlainObject(b)) {
      const aSize = array ? a.length : Object.keys(a).length;
      const bItems = array ? b : Object.keys(b);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i = 0; i < bSize; i++) {
        const key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(a[key], b[key]);
        if (copy[key] === a[key]) {
          equalItems++;
        }
      }
      return aSize === bSize && equalItems === aSize ? a : copy;
    }
    return b;
  }

  /**
   * Shallow compare objects. Only works with objects that always have the same properties.
   */
  function shallowEqualObjects(a, b) {
    if (a && !b || b && !a) {
      return false;
    }
    for (const key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }

  // Copied from: https://github.com/jonschlinkert/is-plain-object
  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    }

    // If has modified constructor
    const ctor = o.constructor;
    if (typeof ctor === 'undefined') {
      return true;
    }

    // If has modified prototype
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }

    // If constructor does not have an Object-specific method
    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    }

    // Most likely a plain Object
    return true;
  }
  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }
  function sleep(timeout) {
    return new Promise(resolve => {
      setTimeout(resolve, timeout);
    });
  }

  /**
   * Schedules a microtask.
   * This can be useful to schedule state updates after rendering.
   */
  function scheduleMicrotask(callback) {
    sleep(0).then(callback);
  }
  function replaceData(prevData, data, options) {
    if (typeof options.structuralSharing === 'function') {
      return options.structuralSharing(prevData, data);
    } else if (options.structuralSharing !== false) {
      // Structurally share data between prev and new data if needed
      return replaceEqualDeep(prevData, data);
    }
    return data;
  }
  function keepPreviousData(previousData) {
    return previousData;
  }
  function addToEnd(items, item, max = 0) {
    const newItems = [...items, item];
    return max && newItems.length > max ? newItems.slice(1) : newItems;
  }
  function addToStart(items, item, max = 0) {
    const newItems = [item, ...items];
    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
  }

  class FocusManager extends Subscribable {
    #focused;
    #cleanup;
    #setup;
    constructor() {
      super();
      this.#setup = onFocus => {
        // addEventListener does not exist in React Native, but window does
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          // Listen to visibilitychange
          window.addEventListener('visibilitychange', listener, false);
          return () => {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('visibilitychange', listener);
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.#cleanup) {
        this.setEventListener(this.#setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.#cleanup?.();
        this.#cleanup = undefined;
      }
    }
    setEventListener(setup) {
      this.#setup = setup;
      this.#cleanup?.();
      this.#cleanup = setup(focused => {
        if (typeof focused === 'boolean') {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      });
    }
    setFocused(focused) {
      this.#focused = focused;
      if (focused) {
        this.onFocus();
      }
    }
    onFocus() {
      this.listeners.forEach(listener => {
        listener();
      });
    }
    isFocused() {
      if (typeof this.#focused === 'boolean') {
        return this.#focused;
      }

      // document global can be unavailable in react native
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      return globalThis.document?.visibilityState !== 'hidden';
    }
  }
  const focusManager = new FocusManager();

  class OnlineManager extends Subscribable {
    #online;
    #cleanup;
    #setup;
    constructor() {
      super();
      this.#setup = onOnline => {
        // addEventListener does not exist in React Native, but window does
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!isServer && window.addEventListener) {
          const listener = () => onOnline();
          // Listen to online
          window.addEventListener('online', listener, false);
          window.addEventListener('offline', listener, false);
          return () => {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('online', listener);
            window.removeEventListener('offline', listener);
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.#cleanup) {
        this.setEventListener(this.#setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.#cleanup?.();
        this.#cleanup = undefined;
      }
    }
    setEventListener(setup) {
      this.#setup = setup;
      this.#cleanup?.();
      this.#cleanup = setup(online => {
        if (typeof online === 'boolean') {
          this.setOnline(online);
        } else {
          this.onOnline();
        }
      });
    }
    setOnline(online) {
      this.#online = online;
      if (online) {
        this.onOnline();
      }
    }
    onOnline() {
      this.listeners.forEach(listener => {
        listener();
      });
    }
    isOnline() {
      if (typeof this.#online === 'boolean') {
        return this.#online;
      }
      if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {
        return true;
      }
      return navigator.onLine;
    }
  }
  const onlineManager = new OnlineManager();

  function defaultRetryDelay(failureCount) {
    return Math.min(1000 * 2 ** failureCount, 30000);
  }
  function canFetch(networkMode) {
    return (networkMode ?? 'online') === 'online' ? onlineManager.isOnline() : true;
  }
  class CancelledError {
    constructor(options) {
      this.revert = options?.revert;
      this.silent = options?.silent;
    }
  }
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((outerResolve, outerReject) => {
      promiseResolve = outerResolve;
      promiseReject = outerReject;
    });
    const cancel = cancelOptions => {
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        config.abort?.();
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();
    const resolve = value => {
      if (!isResolved) {
        isResolved = true;
        config.onSuccess?.(value);
        continueFn?.();
        promiseResolve(value);
      }
    };
    const reject = value => {
      if (!isResolved) {
        isResolved = true;
        config.onError?.(value);
        continueFn?.();
        promiseReject(value);
      }
    };
    const pause = () => {
      return new Promise(continueResolve => {
        continueFn = value => {
          const canContinue = isResolved || !shouldPause();
          if (canContinue) {
            continueResolve(value);
          }
          return canContinue;
        };
        config.onPause?.();
      }).then(() => {
        continueFn = undefined;
        if (!isResolved) {
          config.onContinue?.();
        }
      });
    };

    // Create loop function
    const run = () => {
      // Do nothing if already resolved
      if (isResolved) {
        return;
      }
      let promiseOrValue;

      // Execute query
      try {
        promiseOrValue = config.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve).catch(error => {
        // Stop if the fetch is already resolved
        if (isResolved) {
          return;
        }

        // Do we need to retry the request?
        const retry = config.retry ?? 3;
        const retryDelay = config.retryDelay ?? defaultRetryDelay;
        const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          // We are done if the query does not need to be retried
          reject(error);
          return;
        }
        failureCount++;

        // Notify on fail
        config.onFail?.(failureCount, error);

        // Delay
        sleep(delay)
        // Pause if the document is not visible or when the device is offline
        .then(() => {
          if (shouldPause()) {
            return pause();
          }
          return;
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };

    // Start loop
    if (canFetch(config.networkMode)) {
      run();
    } else {
      pause().then(run);
    }
    return {
      promise,
      cancel,
      continue: () => {
        const didContinue = continueFn?.();
        return didContinue ? promise : Promise.resolve();
      },
      cancelRetry,
      continueRetry
    };
  }

  // TYPES

  function createNotifyManager() {
    let queue = [];
    let transactions = 0;
    let notifyFn = callback => {
      callback();
    };
    let batchNotifyFn = callback => {
      callback();
    };
    const batch = callback => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    };
    const schedule = callback => {
      if (transactions) {
        queue.push(callback);
      } else {
        scheduleMicrotask(() => {
          notifyFn(callback);
        });
      }
    };

    /**
     * All calls to the wrapped function will be batched.
     */
    const batchCalls = callback => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    };
    const flush = () => {
      const originalQueue = queue;
      queue = [];
      if (originalQueue.length) {
        scheduleMicrotask(() => {
          batchNotifyFn(() => {
            originalQueue.forEach(callback => {
              notifyFn(callback);
            });
          });
        });
      }
    };

    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    const setNotifyFunction = fn => {
      notifyFn = fn;
    };

    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    const setBatchNotifyFunction = fn => {
      batchNotifyFn = fn;
    };
    return {
      batch,
      batchCalls,
      schedule,
      setNotifyFunction,
      setBatchNotifyFunction
    };
  }

  // SINGLETON
  const notifyManager = createNotifyManager();

  class Removable {
    #gcTimeout;
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.gcTime)) {
        this.#gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.gcTime);
      }
    }
    updateGcTime(newGcTime) {
      // Default to 5 minutes (Infinity for server-side) if no gcTime is set
      this.gcTime = Math.max(this.gcTime || 0, newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000));
    }
    clearGcTimeout() {
      if (this.#gcTimeout) {
        clearTimeout(this.#gcTimeout);
        this.#gcTimeout = undefined;
      }
    }
  }

  // TYPES

  // CLASS

  class Query extends Removable {
    #initialState;
    #revertState;
    #cache;
    #promise;
    #retryer;
    #observers;
    #defaultOptions;
    #abortSignalConsumed;
    constructor(config) {
      super();
      this.#abortSignalConsumed = false;
      this.#defaultOptions = config.defaultOptions;
      this.#setOptions(config.options);
      this.#observers = [];
      this.#cache = config.cache;
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      this.#initialState = config.state || getDefaultState$1(this.options);
      this.state = this.#initialState;
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    #setOptions(options) {
      this.options = {
        ...this.#defaultOptions,
        ...options
      };
      this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      if (!this.#observers.length && this.state.fetchStatus === 'idle') {
        this.#cache.remove(this);
      }
    }
    setData(newData, options) {
      const data = replaceData(this.state.data, newData, this.options);

      // Set data and mark it as cached
      this.#dispatch({
        data,
        type: 'success',
        dataUpdatedAt: options?.updatedAt,
        manual: options?.manual
      });
      return data;
    }
    setState(state, setStateOptions) {
      this.#dispatch({
        type: 'setState',
        state,
        setStateOptions
      });
    }
    cancel(options) {
      const promise = this.#promise;
      this.#retryer?.cancel(options);
      return promise ? promise.then(noop).catch(noop) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({
        silent: true
      });
    }
    reset() {
      this.destroy();
      this.setState(this.#initialState);
    }
    isActive() {
      return this.#observers.some(observer => observer.options.enabled !== false);
    }
    isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive();
    }
    isStale() {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#observers.some(observer => observer.getCurrentResult().isStale);
    }
    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      const observer = this.#observers.find(x => x.shouldFetchOnWindowFocus());
      observer?.refetch({
        cancelRefetch: false
      });

      // Continue fetch if currently paused
      this.#retryer?.continue();
    }
    onOnline() {
      const observer = this.#observers.find(x => x.shouldFetchOnReconnect());
      observer?.refetch({
        cancelRefetch: false
      });

      // Continue fetch if currently paused
      this.#retryer?.continue();
    }
    addObserver(observer) {
      if (this.#observers.indexOf(observer) === -1) {
        this.#observers.push(observer);

        // Stop the query from being garbage collected
        this.clearGcTimeout();
        this.#cache.notify({
          type: 'observerAdded',
          query: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      if (this.#observers.indexOf(observer) !== -1) {
        this.#observers = this.#observers.filter(x => x !== observer);
        if (!this.#observers.length) {
          // If the transport layer does not support cancellation
          // we'll let the query continue so the result can be cached
          if (this.#retryer) {
            if (this.#abortSignalConsumed) {
              this.#retryer.cancel({
                revert: true
              });
            } else {
              this.#retryer.cancelRetry();
            }
          }
          this.scheduleGc();
        }
        this.#cache.notify({
          type: 'observerRemoved',
          query: this,
          observer
        });
      }
    }
    getObserversCount() {
      return this.#observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        this.#dispatch({
          type: 'invalidate'
        });
      }
    }
    fetch(options, fetchOptions) {
      if (this.state.fetchStatus !== 'idle') {
        if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {
          // Silently cancel current fetch if the user wants to cancel refetches
          this.cancel({
            silent: true
          });
        } else if (this.#promise) {
          // make sure that retries that were potentially cancelled due to unmounts can continue
          this.#retryer?.continueRetry();
          // Return current promise if we are already fetching
          return this.#promise;
        }
      }

      // Update config if passed, otherwise the config from the last execution is used
      if (options) {
        this.#setOptions(options);
      }

      // Use the options from the first observer with a query function if no function is found.
      // This can happen when the query is hydrated or created with setQueryData.
      if (!this.options.queryFn) {
        const observer = this.#observers.find(x => x.options.queryFn);
        if (observer) {
          this.#setOptions(observer.options);
        }
      }
      {
        if (!Array.isArray(this.options.queryKey)) {
          console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);
        }
      }
      const abortController = new AbortController();

      // Create query function context
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };

      // Adds an enumerable signal property to the object that
      // which sets abortSignalConsumed to true when the signal
      // is read.
      const addSignalProperty = object => {
        Object.defineProperty(object, 'signal', {
          enumerable: true,
          get: () => {
            this.#abortSignalConsumed = true;
            return abortController.signal;
          }
        });
      };
      addSignalProperty(queryFnContext);

      // Create fetch function
      const fetchFn = () => {
        if (!this.options.queryFn) {
          return Promise.reject(new Error('Missing queryFn'));
        }
        this.#abortSignalConsumed = false;
        return this.options.queryFn(queryFnContext);
      };

      // Trigger behavior hook
      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context);
      this.options.behavior?.onFetch(context);

      // Store state in case the current fetch needs to be reverted
      this.#revertState = this.state;

      // Set to fetching state if not already in it
      if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== context.fetchOptions?.meta) {
        this.#dispatch({
          type: 'fetch',
          meta: context.fetchOptions?.meta
        });
      }
      const onError = error => {
        // Optimistically update state if needed
        if (!(isCancelledError(error) && error.silent)) {
          this.#dispatch({
            type: 'error',
            error: error
          });
        }
        if (!isCancelledError(error)) {
          // Notify cache callback
          this.#cache.config.onError?.(error, this);
          this.#cache.config.onSettled?.(this.state.data, error, this);
        }
        if (!this.isFetchingOptimistic) {
          // Schedule query gc after fetching
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      };

      // Try to fetch the data
      this.#retryer = createRetryer({
        fn: context.fetchFn,
        abort: abortController.abort.bind(abortController),
        onSuccess: data => {
          if (typeof data === 'undefined') {
            {
              console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);
            }
            onError(new Error(`${this.queryHash} data is undefined`));
            return;
          }
          this.setData(data);

          // Notify cache callback
          this.#cache.config.onSuccess?.(data, this);
          this.#cache.config.onSettled?.(data, this.state.error, this);
          if (!this.isFetchingOptimistic) {
            // Schedule query gc after fetching
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        },
        onError,
        onFail: (failureCount, error) => {
          this.#dispatch({
            type: 'failed',
            failureCount,
            error
          });
        },
        onPause: () => {
          this.#dispatch({
            type: 'pause'
          });
        },
        onContinue: () => {
          this.#dispatch({
            type: 'continue'
          });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode
      });
      this.#promise = this.#retryer.promise;
      return this.#promise;
    }
    #dispatch(action) {
      const reducer = state => {
        switch (action.type) {
          case 'failed':
            return {
              ...state,
              fetchFailureCount: action.failureCount,
              fetchFailureReason: action.error
            };
          case 'pause':
            return {
              ...state,
              fetchStatus: 'paused'
            };
          case 'continue':
            return {
              ...state,
              fetchStatus: 'fetching'
            };
          case 'fetch':
            return {
              ...state,
              fetchFailureCount: 0,
              fetchFailureReason: null,
              fetchMeta: action.meta ?? null,
              fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',
              ...(!state.dataUpdatedAt && {
                error: null,
                status: 'pending'
              })
            };
          case 'success':
            return {
              ...state,
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: false,
              status: 'success',
              ...(!action.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null
              })
            };
          case 'error':
            const error = action.error;
            if (isCancelledError(error) && error.revert && this.#revertState) {
              return {
                ...this.#revertState
              };
            }
            return {
              ...state,
              error: error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              fetchFailureReason: error,
              fetchStatus: 'idle',
              status: 'error'
            };
          case 'invalidate':
            return {
              ...state,
              isInvalidated: true
            };
          case 'setState':
            return {
              ...state,
              ...action.state
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.#observers.forEach(observer => {
          observer.onQueryUpdate();
        });
        this.#cache.notify({
          query: this,
          type: 'updated',
          action
        });
      });
    }
  }
  function getDefaultState$1(options) {
    const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;
    const hasData = typeof data !== 'undefined';
    const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? 'success' : 'pending',
      fetchStatus: 'idle'
    };
  }

  // CLASS

  class QueryCache extends Subscribable {
    #queries;
    constructor(config = {}) {
      super();
      this.config = config;
      this.#queries = new Map();
    }
    build(client, options, state) {
      const queryKey = options.queryKey;
      const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          cache: this,
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options),
          state,
          defaultOptions: client.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!this.#queries.has(query.queryHash)) {
        this.#queries.set(query.queryHash, query);
        this.notify({
          type: 'added',
          query
        });
      }
    }
    remove(query) {
      const queryInMap = this.#queries.get(query.queryHash);
      if (queryInMap) {
        query.destroy();
        if (queryInMap === query) {
          this.#queries.delete(query.queryHash);
        }
        this.notify({
          type: 'removed',
          query
        });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach(query => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return this.#queries.get(queryHash);
    }
    getAll() {
      return [...this.#queries.values()];
    }
    find(filters) {
      const defaultedFilters = {
        exact: true,
        ...filters
      };
      return this.getAll().find(query => matchQuery(defaultedFilters, query));
    }
    findAll(filters = {}) {
      const queries = this.getAll();
      return Object.keys(filters).length > 0 ? queries.filter(query => matchQuery(filters, query)) : queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.getAll().forEach(query => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.getAll().forEach(query => {
          query.onOnline();
        });
      });
    }
  }

  // TYPES

  // CLASS

  class Mutation extends Removable {
    #observers;
    #defaultOptions;
    #mutationCache;
    #retryer;
    constructor(config) {
      super();
      this.mutationId = config.mutationId;
      this.#defaultOptions = config.defaultOptions;
      this.#mutationCache = config.mutationCache;
      this.#observers = [];
      this.state = config.state || getDefaultState();
      this.setOptions(config.options);
      this.scheduleGc();
    }
    setOptions(options) {
      this.options = {
        ...this.#defaultOptions,
        ...options
      };
      this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(observer) {
      if (this.#observers.indexOf(observer) === -1) {
        this.#observers.push(observer);

        // Stop the mutation from being garbage collected
        this.clearGcTimeout();
        this.#mutationCache.notify({
          type: 'observerAdded',
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      this.#observers = this.#observers.filter(x => x !== observer);
      this.scheduleGc();
      this.#mutationCache.notify({
        type: 'observerRemoved',
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!this.#observers.length) {
        if (this.state.status === 'pending') {
          this.scheduleGc();
        } else {
          this.#mutationCache.remove(this);
        }
      }
    }
    continue() {
      return this.#retryer?.continue() ??
      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
      this.execute(this.state.variables);
    }
    async execute(variables) {
      const executeMutation = () => {
        this.#retryer = createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject(new Error('No mutationFn found'));
            }
            return this.options.mutationFn(variables);
          },
          onFail: (failureCount, error) => {
            this.#dispatch({
              type: 'failed',
              failureCount,
              error
            });
          },
          onPause: () => {
            this.#dispatch({
              type: 'pause'
            });
          },
          onContinue: () => {
            this.#dispatch({
              type: 'continue'
            });
          },
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode
        });
        return this.#retryer.promise;
      };
      const restored = this.state.status === 'pending';
      try {
        if (!restored) {
          this.#dispatch({
            type: 'pending',
            variables
          });
          // Notify cache callback
          await this.#mutationCache.config.onMutate?.(variables, this);
          const context = await this.options.onMutate?.(variables);
          if (context !== this.state.context) {
            this.#dispatch({
              type: 'pending',
              context,
              variables
            });
          }
        }
        const data = await executeMutation();

        // Notify cache callback
        await this.#mutationCache.config.onSuccess?.(data, variables, this.state.context, this);
        await this.options.onSuccess?.(data, variables, this.state.context);

        // Notify cache callback
        await this.#mutationCache.config.onSettled?.(data, null, this.state.variables, this.state.context, this);
        await this.options.onSettled?.(data, null, variables, this.state.context);
        this.#dispatch({
          type: 'success',
          data
        });
        return data;
      } catch (error) {
        try {
          // Notify cache callback
          await this.#mutationCache.config.onError?.(error, variables, this.state.context, this);
          await this.options.onError?.(error, variables, this.state.context);

          // Notify cache callback
          await this.#mutationCache.config.onSettled?.(undefined, error, this.state.variables, this.state.context, this);
          await this.options.onSettled?.(undefined, error, variables, this.state.context);
          throw error;
        } finally {
          this.#dispatch({
            type: 'error',
            error: error
          });
        }
      }
    }
    #dispatch(action) {
      const reducer = state => {
        switch (action.type) {
          case 'failed':
            return {
              ...state,
              failureCount: action.failureCount,
              failureReason: action.error
            };
          case 'pause':
            return {
              ...state,
              isPaused: true
            };
          case 'continue':
            return {
              ...state,
              isPaused: false
            };
          case 'pending':
            return {
              ...state,
              context: action.context,
              data: undefined,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: !canFetch(this.options.networkMode),
              status: 'pending',
              variables: action.variables,
              submittedAt: Date.now()
            };
          case 'success':
            return {
              ...state,
              data: action.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: false
            };
          case 'error':
            return {
              ...state,
              data: undefined,
              error: action.error,
              failureCount: state.failureCount + 1,
              failureReason: action.error,
              isPaused: false,
              status: 'error'
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.#observers.forEach(observer => {
          observer.onMutationUpdate(action);
        });
        this.#mutationCache.notify({
          mutation: this,
          type: 'updated',
          action
        });
      });
    }
  }
  function getDefaultState() {
    return {
      context: undefined,
      data: undefined,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: 'idle',
      variables: undefined,
      submittedAt: 0
    };
  }

  // TYPES

  // CLASS

  class MutationCache extends Subscribable {
    #mutations;
    #mutationId;
    #resuming;
    constructor(config = {}) {
      super();
      this.config = config;
      this.#mutations = [];
      this.#mutationId = 0;
    }
    build(client, options, state) {
      const mutation = new Mutation({
        mutationCache: this,
        mutationId: ++this.#mutationId,
        options: client.defaultMutationOptions(options),
        state
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      this.#mutations.push(mutation);
      this.notify({
        type: 'added',
        mutation
      });
    }
    remove(mutation) {
      this.#mutations = this.#mutations.filter(x => x !== mutation);
      this.notify({
        type: 'removed',
        mutation
      });
    }
    clear() {
      notifyManager.batch(() => {
        this.#mutations.forEach(mutation => {
          this.remove(mutation);
        });
      });
    }
    getAll() {
      return this.#mutations;
    }
    find(filters) {
      const defaultedFilters = {
        exact: true,
        ...filters
      };
      return this.#mutations.find(mutation => matchMutation(defaultedFilters, mutation));
    }
    findAll(filters = {}) {
      return this.#mutations.filter(mutation => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      this.#resuming = (this.#resuming ?? Promise.resolve()).then(() => {
        const pausedMutations = this.#mutations.filter(x => x.state.isPaused);
        return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
      }).then(() => {
        this.#resuming = undefined;
      });
      return this.#resuming;
    }
  }

  function infiniteQueryBehavior() {
    return {
      onFetch: context => {
        context.fetchFn = async () => {
          const options = context.options;
          const direction = context.fetchOptions?.meta?.fetchMore?.direction;
          const oldPages = context.state.data?.pages || [];
          const oldPageParams = context.state.data?.pageParams || [];
          const empty = {
            pages: [],
            pageParams: []
          };
          let cancelled = false;
          const addSignalProperty = object => {
            Object.defineProperty(object, 'signal', {
              enumerable: true,
              get: () => {
                if (context.signal.aborted) {
                  cancelled = true;
                } else {
                  context.signal.addEventListener('abort', () => {
                    cancelled = true;
                  });
                }
                return context.signal;
              }
            });
          };

          // Get query function
          const queryFn = context.options.queryFn || (() => Promise.reject(new Error('Missing queryFn')));

          // Create function to fetch a page
          const fetchPage = async (data, param, previous) => {
            if (cancelled) {
              return Promise.reject();
            }
            if (typeof param === 'undefined' && data.pages.length) {
              return Promise.resolve(data);
            }
            const queryFnContext = {
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? 'backward' : 'forward',
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext);
            const page = await queryFn(queryFnContext);
            const {
              maxPages
            } = context.options;
            const addTo = previous ? addToStart : addToEnd;
            return {
              pages: addTo(data.pages, page, maxPages),
              pageParams: addTo(data.pageParams, param, maxPages)
            };
          };
          let result;

          // Fetch first page?
          if (!oldPages.length) {
            result = await fetchPage(empty, options.defaultPageParam);
          }

          // fetch next / previous page?
          else if (direction) {
            const previous = direction === 'backward';
            const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
            const oldData = {
              pages: oldPages,
              pageParams: oldPageParams
            };
            const param = pageParamFn(options, oldData);
            result = await fetchPage(oldData, param, previous);
          }

          // Refetch pages
          else {
            // Fetch first page
            result = await fetchPage(empty, oldPageParams[0]);

            // Fetch remaining pages
            for (let i = 1; i < oldPages.length; i++) {
              const param = getNextPageParam(options, result);
              result = await fetchPage(result, param);
            }
          }
          return result;
        };
      }
    };
  }
  function getNextPageParam(options, {
    pages,
    pageParams
  }) {
    const lastIndex = pages.length - 1;
    return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);
  }
  function getPreviousPageParam(options, {
    pages,
    pageParams
  }) {
    return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);
  }

  /**
   * Checks if there is a next page.
   */
  function hasNextPage(options, data) {
    if (!data) return false;
    return typeof getNextPageParam(options, data) !== 'undefined';
  }

  /**
   * Checks if there is a previous page.
   */
  function hasPreviousPage(options, data) {
    if (!data || !options.getPreviousPageParam) return false;
    return typeof getPreviousPageParam(options, data) !== 'undefined';
  }

  // TYPES

  // CLASS

  class QueryClient {
    #queryCache;
    #mutationCache;
    #defaultOptions;
    #queryDefaults;
    #mutationDefaults;
    #mountCount;
    #unsubscribeFocus;
    #unsubscribeOnline;
    constructor(config = {}) {
      this.#queryCache = config.queryCache || new QueryCache();
      this.#mutationCache = config.mutationCache || new MutationCache();
      this.#defaultOptions = config.defaultOptions || {};
      this.#queryDefaults = new Map();
      this.#mutationDefaults = new Map();
      this.#mountCount = 0;
    }
    mount() {
      this.#mountCount++;
      if (this.#mountCount !== 1) return;
      this.#unsubscribeFocus = focusManager.subscribe(() => {
        if (focusManager.isFocused()) {
          this.resumePausedMutations();
          this.#queryCache.onFocus();
        }
      });
      this.#unsubscribeOnline = onlineManager.subscribe(() => {
        if (onlineManager.isOnline()) {
          this.resumePausedMutations();
          this.#queryCache.onOnline();
        }
      });
    }
    unmount() {
      this.#mountCount--;
      if (this.#mountCount !== 0) return;
      this.#unsubscribeFocus?.();
      this.#unsubscribeFocus = undefined;
      this.#unsubscribeOnline?.();
      this.#unsubscribeOnline = undefined;
    }
    isFetching(filters) {
      return this.#queryCache.findAll({
        ...filters,
        fetchStatus: 'fetching'
      }).length;
    }
    isMutating(filters) {
      return this.#mutationCache.findAll({
        ...filters,
        status: 'pending'
      }).length;
    }
    getQueryData(queryKey) {
      return this.#queryCache.find({
        queryKey
      })?.state.data;
    }
    ensureQueryData(options) {
      const cachedData = this.getQueryData(options.queryKey);
      return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(options);
    }
    getQueriesData(filters) {
      return this.getQueryCache().findAll(filters).map(({
        queryKey,
        state
      }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }
    setQueryData(queryKey, updater, options) {
      const query = this.#queryCache.find({
        queryKey
      });
      const prevData = query?.state.data;
      const data = functionalUpdate(updater, prevData);
      if (typeof data === 'undefined') {
        return undefined;
      }
      const defaultedOptions = this.defaultQueryOptions({
        queryKey
      });
      return this.#queryCache.build(this, defaultedOptions).setData(data, {
        ...options,
        manual: true
      });
    }
    setQueriesData(filters, updater, options) {
      return notifyManager.batch(() => this.getQueryCache().findAll(filters).map(({
        queryKey
      }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
    }
    getQueryState(queryKey) {
      return this.#queryCache.find({
        queryKey
      })?.state;
    }
    removeQueries(filters) {
      const queryCache = this.#queryCache;
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach(query => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(filters, options) {
      const queryCache = this.#queryCache;
      const refetchFilters = {
        type: 'active',
        ...filters
      };
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach(query => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options);
      });
    }
    cancelQueries(filters = {}, cancelOptions = {}) {
      const defaultedCancelOptions = {
        revert: true,
        ...cancelOptions
      };
      const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).map(query => query.cancel(defaultedCancelOptions)));
      return Promise.all(promises).then(noop).catch(noop);
    }
    invalidateQueries(filters = {}, options = {}) {
      return notifyManager.batch(() => {
        this.#queryCache.findAll(filters).forEach(query => {
          query.invalidate();
        });
        if (filters.refetchType === 'none') {
          return Promise.resolve();
        }
        const refetchFilters = {
          ...filters,
          type: filters.refetchType ?? filters.type ?? 'active'
        };
        return this.refetchQueries(refetchFilters, options);
      });
    }
    refetchQueries(filters = {}, options) {
      const fetchOptions = {
        ...options,
        cancelRefetch: options?.cancelRefetch ?? true
      };
      const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {
        let promise = query.fetch(undefined, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === 'paused' ? Promise.resolve() : promise;
      }));
      return Promise.all(promises).then(noop);
    }
    fetchQuery(options) {
      const defaultedOptions = this.defaultQueryOptions(options);

      // https://github.com/tannerlinsley/react-query/issues/652
      if (typeof defaultedOptions.retry === 'undefined') {
        defaultedOptions.retry = false;
      }
      const query = this.#queryCache.build(this, defaultedOptions);
      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    prefetchQuery(options) {
      return this.fetchQuery(options).then(noop).catch(noop);
    }
    fetchInfiniteQuery(options) {
      options.behavior = infiniteQueryBehavior();
      return this.fetchQuery(options);
    }
    prefetchInfiniteQuery(options) {
      return this.fetchInfiniteQuery(options).then(noop).catch(noop);
    }
    resumePausedMutations() {
      return this.#mutationCache.resumePausedMutations();
    }
    getQueryCache() {
      return this.#queryCache;
    }
    getMutationCache() {
      return this.#mutationCache;
    }
    getDefaultOptions() {
      return this.#defaultOptions;
    }
    setDefaultOptions(options) {
      this.#defaultOptions = options;
    }
    setQueryDefaults(queryKey, options) {
      this.#queryDefaults.set(hashKey(queryKey), {
        queryKey,
        defaultOptions: options
      });
    }
    getQueryDefaults(queryKey) {
      const defaults = [...this.#queryDefaults.values()];
      let result = {};
      defaults.forEach(queryDefault => {
        if (partialMatchKey(queryKey, queryDefault.queryKey)) {
          result = {
            ...result,
            ...queryDefault.defaultOptions
          };
        }
      });
      return result;
    }
    setMutationDefaults(mutationKey, options) {
      this.#mutationDefaults.set(hashKey(mutationKey), {
        mutationKey,
        defaultOptions: options
      });
    }
    getMutationDefaults(mutationKey) {
      const defaults = [...this.#mutationDefaults.values()];
      let result = {};
      defaults.forEach(queryDefault => {
        if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
          result = {
            ...result,
            ...queryDefault.defaultOptions
          };
        }
      });
      return result;
    }
    defaultQueryOptions(options) {
      if (options?._defaulted) {
        return options;
      }
      const defaultedOptions = {
        ...this.#defaultOptions.queries,
        ...(options?.queryKey && this.getQueryDefaults(options.queryKey)),
        ...options,
        _defaulted: true
      };
      if (!defaultedOptions.queryHash) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
      }

      // dependent default values
      if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';
      }
      if (typeof defaultedOptions.throwOnError === 'undefined') {
        defaultedOptions.throwOnError = !!defaultedOptions.suspense;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options) {
      if (options?._defaulted) {
        return options;
      }
      return {
        ...this.#defaultOptions.mutations,
        ...(options?.mutationKey && this.getMutationDefaults(options.mutationKey)),
        ...options,
        _defaulted: true
      };
    }
    clear() {
      this.#queryCache.clear();
      this.#mutationCache.clear();
    }
  }

  class QueryObserver extends Subscribable {
    #client;
    #currentQuery = undefined;
    #currentQueryInitialState = undefined;
    #currentResult = undefined;
    #currentResultState;
    #currentResultOptions;
    #selectError;
    #selectFn;
    #selectResult;
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    #lastQueryWithDefinedData;
    #staleTimeoutId;
    #refetchIntervalId;
    #currentRefetchInterval;
    #trackedProps = new Set();
    constructor(client, options) {
      super();
      this.#client = client;
      this.options = options;
      this.#selectError = null;
      this.bindMethods();
      this.setOptions(options);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        this.#currentQuery.addObserver(this);
        if (shouldFetchOnMount(this.#currentQuery, this.options)) {
          this.#executeFetch();
        }
        this.#updateTimers();
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
      this.listeners = new Set();
      this.#clearStaleTimeout();
      this.#clearRefetchInterval();
      this.#currentQuery.removeObserver(this);
    }
    setOptions(options, notifyOptions) {
      const prevOptions = this.options;
      const prevQuery = this.#currentQuery;
      this.options = this.#client.defaultQueryOptions(options);
      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.#client.getQueryCache().notify({
          type: 'observerOptionsUpdated',
          query: this.#currentQuery,
          observer: this
        });
      }
      if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {
        throw new Error('Expected enabled to be a boolean');
      }

      // Keep previous query key if the user does not supply one
      if (!this.options.queryKey) {
        this.options.queryKey = prevOptions.queryKey;
      }
      this.#updateQuery();
      const mounted = this.hasListeners();

      // Fetch if there are subscribers
      if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {
        this.#executeFetch();
      }

      // Update result
      this.#updateResult(notifyOptions);

      // Update stale interval if needed
      if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
        this.#updateStaleTimeout();
      }
      const nextRefetchInterval = this.#computeRefetchInterval();

      // Update refetch interval if needed
      if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {
        this.#updateRefetchInterval(nextRefetchInterval);
      }
    }
    getOptimisticResult(options) {
      const query = this.#client.getQueryCache().build(this.#client, options);
      return this.createResult(query, options);
    }
    getCurrentResult() {
      return this.#currentResult;
    }
    trackResult(result) {
      const trackedResult = {};
      Object.keys(result).forEach(key => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.#trackedProps.add(key);
            return result[key];
          }
        });
      });
      return trackedResult;
    }
    getCurrentQuery() {
      return this.#currentQuery;
    }
    refetch({
      ...options
    } = {}) {
      return this.fetch({
        ...options
      });
    }
    fetchOptimistic(options) {
      const defaultedOptions = this.#client.defaultQueryOptions(options);
      const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
      query.isFetchingOptimistic = true;
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      return this.#executeFetch({
        ...fetchOptions,
        cancelRefetch: fetchOptions.cancelRefetch ?? true
      }).then(() => {
        this.#updateResult();
        return this.#currentResult;
      });
    }
    #executeFetch(fetchOptions) {
      // Make sure we reference the latest query as the current one might have been removed
      this.#updateQuery();

      // Fetch
      let promise = this.#currentQuery.fetch(this.options, fetchOptions);
      if (!fetchOptions?.throwOnError) {
        promise = promise.catch(noop);
      }
      return promise;
    }
    #updateStaleTimeout() {
      this.#clearStaleTimeout();
      if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
        return;
      }
      const time = timeUntilStale(this.#currentResult.dataUpdatedAt, this.options.staleTime);

      // The timeout is sometimes triggered 1 ms before the stale time expiration.
      // To mitigate this issue we always add 1 ms to the timeout.
      const timeout = time + 1;
      this.#staleTimeoutId = setTimeout(() => {
        if (!this.#currentResult.isStale) {
          this.#updateResult();
        }
      }, timeout);
    }
    #computeRefetchInterval() {
      return (typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.#currentResult.data, this.#currentQuery) : this.options.refetchInterval) ?? false;
    }
    #updateRefetchInterval(nextInterval) {
      this.#clearRefetchInterval();
      this.#currentRefetchInterval = nextInterval;
      if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
        return;
      }
      this.#refetchIntervalId = setInterval(() => {
        if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
          this.#executeFetch();
        }
      }, this.#currentRefetchInterval);
    }
    #updateTimers() {
      this.#updateStaleTimeout();
      this.#updateRefetchInterval(this.#computeRefetchInterval());
    }
    #clearStaleTimeout() {
      if (this.#staleTimeoutId) {
        clearTimeout(this.#staleTimeoutId);
        this.#staleTimeoutId = undefined;
      }
    }
    #clearRefetchInterval() {
      if (this.#refetchIntervalId) {
        clearInterval(this.#refetchIntervalId);
        this.#refetchIntervalId = undefined;
      }
    }
    createResult(query, options) {
      const prevQuery = this.#currentQuery;
      const prevOptions = this.options;
      const prevResult = this.#currentResult;
      const prevResultState = this.#currentResultState;
      const prevResultOptions = this.#currentResultOptions;
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
      const {
        state
      } = query;
      let {
        error,
        errorUpdatedAt,
        fetchStatus,
        status
      } = state;
      let isPlaceholderData = false;
      let data;

      // Optimistically set result in fetching state if needed
      if (options._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';
          if (!state.dataUpdatedAt) {
            status = 'pending';
          }
        }
        if (options._optimisticResults === 'isRestoring') {
          fetchStatus = 'idle';
        }
      }

      // Select data if needed
      if (options.select && typeof state.data !== 'undefined') {
        // Memoize select result
        if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {
          data = this.#selectResult;
        } else {
          try {
            this.#selectFn = options.select;
            data = options.select(state.data);
            data = replaceData(prevResult?.data, data, options);
            this.#selectResult = data;
            this.#selectError = null;
          } catch (selectError) {
            this.#selectError = selectError;
          }
        }
      }
      // Use query data
      else {
        data = state.data;
      }

      // Show placeholder data if needed
      if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'pending') {
        let placeholderData;

        // Memoize placeholder data
        if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options.placeholderData;
          if (options.select && typeof placeholderData !== 'undefined') {
            try {
              placeholderData = options.select(placeholderData);
              this.#selectError = null;
            } catch (selectError) {
              this.#selectError = selectError;
            }
          }
        }
        if (typeof placeholderData !== 'undefined') {
          status = 'success';
          data = replaceData(prevResult?.data, placeholderData, options);
          isPlaceholderData = true;
        }
      }
      if (this.#selectError) {
        error = this.#selectError;
        data = this.#selectResult;
        errorUpdatedAt = Date.now();
        status = 'error';
      }
      const isFetching = fetchStatus === 'fetching';
      const isPending = status === 'pending';
      const isError = status === 'error';
      const isLoading = isPending && isFetching;
      const result = {
        status,
        fetchStatus,
        isPending,
        isSuccess: status === 'success',
        isError,
        isInitialLoading: isLoading,
        isLoading,
        data,
        dataUpdatedAt: state.dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: state.fetchFailureCount,
        failureReason: state.fetchFailureReason,
        errorUpdateCount: state.errorUpdateCount,
        isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
        isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isPending,
        isLoadingError: isError && state.dataUpdatedAt === 0,
        isPaused: fetchStatus === 'paused',
        isPlaceholderData,
        isRefetchError: isError && state.dataUpdatedAt !== 0,
        isStale: isStale(query, options),
        refetch: this.refetch
      };
      return result;
    }
    #updateResult(notifyOptions) {
      const prevResult = this.#currentResult;
      const nextResult = this.createResult(this.#currentQuery, this.options);
      this.#currentResultState = this.#currentQuery.state;
      this.#currentResultOptions = this.options;

      // Only notify and update result if something has changed
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      if (this.#currentResultState.data !== undefined) {
        this.#lastQueryWithDefinedData = this.#currentQuery;
      }
      this.#currentResult = nextResult;

      // Determine which callbacks to trigger
      const defaultNotifyOptions = {};
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const {
          notifyOnChangeProps
        } = this.options;
        if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.#trackedProps.size) {
          return true;
        }
        const includedProps = new Set(notifyOnChangeProps ?? this.#trackedProps);
        if (this.options.throwOnError) {
          includedProps.add('error');
        }
        return Object.keys(this.#currentResult).some(key => {
          const typedKey = key;
          const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {
        defaultNotifyOptions.listeners = true;
      }
      this.#notify({
        ...defaultNotifyOptions,
        ...notifyOptions
      });
    }
    #updateQuery() {
      const query = this.#client.getQueryCache().build(this.#client, this.options);
      if (query === this.#currentQuery) {
        return;
      }
      const prevQuery = this.#currentQuery;
      this.#currentQuery = query;
      this.#currentQueryInitialState = query.state;
      if (this.hasListeners()) {
        prevQuery?.removeObserver(this);
        query.addObserver(this);
      }
    }
    onQueryUpdate() {
      this.#updateResult();
      if (this.hasListeners()) {
        this.#updateTimers();
      }
    }
    #notify(notifyOptions) {
      notifyManager.batch(() => {
        // First, trigger the listeners
        if (notifyOptions.listeners) {
          this.listeners.forEach(listener => {
            listener(this.#currentResult);
          });
        }

        // Then the cache listeners
        this.#client.getQueryCache().notify({
          query: this.#currentQuery,
          type: 'observerResultsUpdated'
        });
      });
    }
  }
  function shouldLoadOnMount(query, options) {
    return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);
  }
  function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
  }
  function shouldFetchOn(query, options, field) {
    if (options.enabled !== false) {
      const value = typeof field === 'function' ? field(query) : field;
      return value === 'always' || value !== false && isStale(query, options);
    }
    return false;
  }
  function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);
  }
  function isStale(query, options) {
    return query.isStaleByTime(options.staleTime);
  }

  function difference(array1, array2) {
    return array1.filter(x => array2.indexOf(x) === -1);
  }
  function replaceAt(array, index, value) {
    const copy = array.slice(0);
    copy[index] = value;
    return copy;
  }
  class QueriesObserver extends Subscribable {
    #client;
    #result;
    #queries;
    #observers;
    #options;
    #combinedResult;
    constructor(client, queries, options) {
      super();
      this.#client = client;
      this.#queries = [];
      this.#observers = [];
      this.#setResult([]);
      this.setQueries(queries, options);
    }
    #setResult(value) {
      this.#result = value;
      this.#combinedResult = this.#combineResult(value);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        this.#observers.forEach(observer => {
          observer.subscribe(result => {
            this.#onUpdate(observer, result);
          });
        });
      }
    }
    onUnsubscribe() {
      if (!this.listeners.size) {
        this.destroy();
      }
    }
    destroy() {
      this.listeners = new Set();
      this.#observers.forEach(observer => {
        observer.destroy();
      });
    }
    setQueries(queries, options, notifyOptions) {
      this.#queries = queries;
      this.#options = options;
      notifyManager.batch(() => {
        const prevObservers = this.#observers;
        const newObserverMatches = this.#findMatchingObservers(this.#queries);

        // set options for the new observers to notify of changes
        newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));
        const newObservers = newObserverMatches.map(match => match.observer);
        const newResult = newObservers.map(observer => observer.getCurrentResult());
        const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);
        if (prevObservers.length === newObservers.length && !hasIndexChange) {
          return;
        }
        this.#observers = newObservers;
        this.#setResult(newResult);
        if (!this.hasListeners()) {
          return;
        }
        difference(prevObservers, newObservers).forEach(observer => {
          observer.destroy();
        });
        difference(newObservers, prevObservers).forEach(observer => {
          observer.subscribe(result => {
            this.#onUpdate(observer, result);
          });
        });
        this.#notify();
      });
    }
    getCurrentResult() {
      return this.#combinedResult;
    }
    getQueries() {
      return this.#observers.map(observer => observer.getCurrentQuery());
    }
    getObservers() {
      return this.#observers;
    }
    getOptimisticResult(queries) {
      const matches = this.#findMatchingObservers(queries);
      const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));
      return [result, r => {
        return this.#combineResult(r ?? result);
      }, () => {
        return matches.map((match, index) => {
          const observerResult = result[index];
          return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult) : observerResult;
        });
      }];
    }
    #combineResult(input) {
      const combine = this.#options?.combine;
      if (combine) {
        return replaceEqualDeep(this.#combinedResult, combine(input));
      }
      return input;
    }
    #findMatchingObservers(queries) {
      const prevObservers = this.#observers;
      const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));
      const defaultedQueryOptions = queries.map(options => this.#client.defaultQueryOptions(options));
      const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {
        const match = prevObserversMap.get(defaultedOptions.queryHash);
        if (match != null) {
          return [{
            defaultedQueryOptions: defaultedOptions,
            observer: match
          }];
        }
        return [];
      });
      const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));
      const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));
      const getObserver = options => {
        const defaultedOptions = this.#client.defaultQueryOptions(options);
        const currentObserver = this.#observers.find(o => o.options.queryHash === defaultedOptions.queryHash);
        return currentObserver ?? new QueryObserver(this.#client, defaultedOptions);
      };
      const newOrReusedObservers = unmatchedQueries.map(options => {
        return {
          defaultedQueryOptions: options,
          observer: getObserver(options)
        };
      });
      const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);
      return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
    }
    #onUpdate(observer, result) {
      const index = this.#observers.indexOf(observer);
      if (index !== -1) {
        this.#setResult(replaceAt(this.#result, index, result));
        this.#notify();
      }
    }
    #notify() {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(this.#result);
        });
      });
    }
  }

  class InfiniteQueryObserver extends QueryObserver {
    // Type override

    // Type override

    // Type override

    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
    constructor(client, options) {
      super(client, options);
    }
    bindMethods() {
      super.bindMethods();
      this.fetchNextPage = this.fetchNextPage.bind(this);
      this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
    }
    setOptions(options, notifyOptions) {
      super.setOptions({
        ...options,
        behavior: infiniteQueryBehavior()
      }, notifyOptions);
    }
    getOptimisticResult(options) {
      options.behavior = infiniteQueryBehavior();
      return super.getOptimisticResult(options);
    }
    fetchNextPage(options) {
      return this.fetch({
        ...options,
        meta: {
          fetchMore: {
            direction: 'forward'
          }
        }
      });
    }
    fetchPreviousPage(options) {
      return this.fetch({
        ...options,
        meta: {
          fetchMore: {
            direction: 'backward'
          }
        }
      });
    }
    createResult(query, options) {
      const {
        state
      } = query;
      const result = super.createResult(query, options);
      const {
        isFetching,
        isRefetching
      } = result;
      const isFetchingNextPage = isFetching && state.fetchMeta?.fetchMore?.direction === 'forward';
      const isFetchingPreviousPage = isFetching && state.fetchMeta?.fetchMore?.direction === 'backward';
      return {
        ...result,
        fetchNextPage: this.fetchNextPage,
        fetchPreviousPage: this.fetchPreviousPage,
        hasNextPage: hasNextPage(options, state.data),
        hasPreviousPage: hasPreviousPage(options, state.data),
        isFetchingNextPage,
        isFetchingPreviousPage,
        isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
      };
    }
  }

  // TYPES

  // CLASS

  class MutationObserver extends Subscribable {
    #client;
    #currentResult = undefined;
    #currentMutation;
    #mutateOptions;
    constructor(client, options) {
      super();
      this.#client = client;
      this.setOptions(options);
      this.bindMethods();
      this.#updateResult();
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    }
    setOptions(options) {
      const prevOptions = this.options;
      this.options = this.#client.defaultMutationOptions(options);
      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.#client.getMutationCache().notify({
          type: 'observerOptionsUpdated',
          mutation: this.#currentMutation,
          observer: this
        });
      }
      this.#currentMutation?.setOptions(this.options);
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.#currentMutation?.removeObserver(this);
      }
    }
    onMutationUpdate(action) {
      this.#updateResult();
      this.#notify(action);
    }
    getCurrentResult() {
      return this.#currentResult;
    }
    reset() {
      this.#currentMutation = undefined;
      this.#updateResult();
      this.#notify();
    }
    mutate(variables, options) {
      this.#mutateOptions = options;
      this.#currentMutation?.removeObserver(this);
      this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
      this.#currentMutation.addObserver(this);
      return this.#currentMutation.execute(variables);
    }
    #updateResult() {
      const state = this.#currentMutation?.state ?? getDefaultState();
      this.#currentResult = {
        ...state,
        isPending: state.status === 'pending',
        isSuccess: state.status === 'success',
        isError: state.status === 'error',
        isIdle: state.status === 'idle',
        mutate: this.mutate,
        reset: this.reset
      };
    }
    #notify(action) {
      notifyManager.batch(() => {
        // First trigger the mutate callbacks
        if (this.#mutateOptions && this.hasListeners()) {
          if (action?.type === 'success') {
            this.#mutateOptions.onSuccess?.(action.data, this.#currentResult.variables, this.#currentResult.context);
            this.#mutateOptions.onSettled?.(action.data, null, this.#currentResult.variables, this.#currentResult.context);
          } else if (action?.type === 'error') {
            this.#mutateOptions.onError?.(action.error, this.#currentResult.variables, this.#currentResult.context);
            this.#mutateOptions.onSettled?.(undefined, action.error, this.#currentResult.variables, this.#currentResult.context);
          }
        }

        // Then trigger the listeners
        this.listeners.forEach(listener => {
          listener(this.#currentResult);
        });
      });
    }
  }

  // TYPES

  // FUNCTIONS

  function dehydrateMutation(mutation) {
    return {
      mutationKey: mutation.options.mutationKey,
      state: mutation.state
    };
  }

  // Most config is not dehydrated but instead meant to configure again when
  // consuming the de/rehydrated data, typically with useQuery on the client.
  // Sometimes it might make sense to prefetch data on the server and include
  // in the html-payload, but not consume it on the initial render.
  function dehydrateQuery(query) {
    return {
      state: query.state,
      queryKey: query.queryKey,
      queryHash: query.queryHash
    };
  }
  function defaultShouldDehydrateMutation(mutation) {
    return mutation.state.isPaused;
  }
  function defaultShouldDehydrateQuery(query) {
    return query.state.status === 'success';
  }
  function dehydrate(client, options = {}) {
    const filterMutation = options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;
    const mutations = client.getMutationCache().getAll().flatMap(mutation => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []);
    const filterQuery = options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;
    const queries = client.getQueryCache().getAll().flatMap(query => filterQuery(query) ? [dehydrateQuery(query)] : []);
    return {
      mutations,
      queries
    };
  }
  function hydrate(client, dehydratedState, options) {
    if (typeof dehydratedState !== 'object' || dehydratedState === null) {
      return;
    }
    const mutationCache = client.getMutationCache();
    const queryCache = client.getQueryCache();

    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    const mutations = dehydratedState.mutations || [];
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    const queries = dehydratedState.queries || [];
    mutations.forEach(dehydratedMutation => {
      mutationCache.build(client, {
        ...options?.defaultOptions?.mutations,
        mutationKey: dehydratedMutation.mutationKey
      }, dehydratedMutation.state);
    });
    queries.forEach(dehydratedQuery => {
      const query = queryCache.get(dehydratedQuery.queryHash);

      // Reset fetch status to idle in the dehydrated state to avoid
      // query being stuck in fetching state upon hydration
      const dehydratedQueryState = {
        ...dehydratedQuery.state,
        fetchStatus: 'idle'
      };

      // Do not hydrate if an existing query exists with newer data
      if (query) {
        if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {
          query.setState(dehydratedQueryState);
        }
        return;
      }

      // Restore query
      queryCache.build(client, {
        ...options?.defaultOptions?.queries,
        queryKey: dehydratedQuery.queryKey,
        queryHash: dehydratedQuery.queryHash
      }, dehydratedQueryState);
    });
  }

  exports.CancelledError = CancelledError;
  exports.InfiniteQueryObserver = InfiniteQueryObserver;
  exports.MutationCache = MutationCache;
  exports.MutationObserver = MutationObserver;
  exports.QueriesObserver = QueriesObserver;
  exports.QueryCache = QueryCache;
  exports.QueryClient = QueryClient;
  exports.QueryObserver = QueryObserver;
  exports.defaultShouldDehydrateMutation = defaultShouldDehydrateMutation;
  exports.defaultShouldDehydrateQuery = defaultShouldDehydrateQuery;
  exports.dehydrate = dehydrate;
  exports.focusManager = focusManager;
  exports.hashKey = hashKey;
  exports.hydrate = hydrate;
  exports.isCancelledError = isCancelledError;
  exports.isServer = isServer;
  exports.keepPreviousData = keepPreviousData;
  exports.matchQuery = matchQuery;
  exports.notifyManager = notifyManager;
  exports.onlineManager = onlineManager;
  exports.replaceEqualDeep = replaceEqualDeep;

}));
//# sourceMappingURL=index.development.js.map
