{"version":3,"file":"index.production.js","sources":["../../src/subscribable.ts","../../src/utils.ts","../../src/focusManager.ts","../../src/onlineManager.ts","../../src/retryer.ts","../../src/notifyManager.ts","../../src/removable.ts","../../src/query.ts","../../src/queryCache.ts","../../src/mutation.ts","../../src/mutationCache.ts","../../src/infiniteQueryBehavior.ts","../../src/queryObserver.ts","../../src/queriesObserver.ts","../../src/hydration.ts","../../src/infiniteQueryObserver.ts","../../src/mutationObserver.ts","../../src/queryClient.ts"],"sourcesContent":["type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<TListener>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: T[], item: T, max = 0): T[] {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: T[], item: T, max = 0): T[] {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.#focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable {\n  #online?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        window.addEventListener('online', listener, false)\n        window.addEventListener('offline', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener)\n          window.removeEventListener('offline', listener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.#online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.#online === 'boolean') {\n      return this.#online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode, DefaultError } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Function>(callback: T): T => {\n    return ((...args: any[]) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n  DefaultError,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #promise?: Promise<TData>\n  #retryer?: Retryer<TData>\n  #observers: QueryObserver<any, any, any, any, any>[]\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.#setOptions(config.options)\n    this.#observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  #setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.#observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.indexOf(observer) === -1) {\n      this.#observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.indexOf(observer) !== -1) {\n      this.#observers = this.#observers.filter((x) => x !== observer)\n\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.#observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.#promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.#setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.#setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: Omit<QueryFunctionContext<TQueryKey>, 'signal'> = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(new Error('Missing queryFn'))\n      }\n      this.#abortSignalConsumed = false\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: Omit<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.#promise = this.#retryer.promise\n\n    return this.#promise\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'pending',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n","import type { QueryFilters } from './utils'\nimport { hashQueryKeyByOptions, matchQuery } from './utils'\nimport type { Action, QueryState } from './query'\nimport { Query } from './query'\nimport type {\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  DefaultError,\n  WithRequired,\n} from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ntype QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryKey: string) => boolean\n  set: (queryKey: string, query: Query) => void\n  get: (queryKey: string) => Query | undefined\n  delete: (queryKey: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Query[] {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters = {}): Query[] {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type {\n  MutationOptions,\n  MutationStatus,\n  MutationMeta,\n  DefaultError,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport type { Retryer } from './retryer'\nimport { canFetch, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  #defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#defaultOptions = config.defaultOptions\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.#observers.indexOf(observer) === -1) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const executeMutation = () => {\n      this.#retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject(new Error('No mutationFn found'))\n          }\n          return this.options.mutationFn(variables)\n        },\n        onFail: (failureCount, error) => {\n          this.#dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.#dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.#dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.#retryer.promise\n    }\n\n    const restored = this.state.status === 'pending'\n\n    try {\n      if (!restored) {\n        this.#dispatch({ type: 'pending', variables })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n","import type { MutationObserver } from './mutationObserver'\nimport type { NotifyEvent, MutationOptions, DefaultError } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Mutation<any, any, any, any>[]\n  #mutationId: number\n  #resuming: Promise<unknown> | undefined\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = []\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations = this.#mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.#mutations\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.#mutations.find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    )\n  }\n\n  findAll(filters: MutationFilters = {}): Mutation[] {\n    return this.#mutations.filter((mutation) =>\n      matchMutation(filters, mutation),\n    )\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.#resuming = (this.#resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.#mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.#resuming = undefined\n      })\n\n    return this.#resuming\n  }\n}\n","import type { QueryBehavior } from './query'\nimport { addToEnd, addToStart } from './utils'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() => Promise.reject(new Error('Missing queryFn')))\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (typeof param === 'undefined' && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: Omit<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          result = await fetchPage(empty, options.defaultPageParam)\n        }\n\n        // fetch next / previous page?\n        else if (direction) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        }\n\n        // Refetch pages\n        else {\n          // Fetch first page\n          result = await fetchPage(empty, oldPageParams[0])\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return typeof getNextPageParam(options, data) !== 'undefined'\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return typeof getPreviousPageParam(options, data) !== 'undefined'\n}\n","import type {\n  DefaultedQueryObserverOptions,\n  DefaultError,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type { Query, QueryState, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps: Set<keyof QueryObserverResult> = new Set()\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.options = options\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.#updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.#updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.#updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.#currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.#updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(\n            this.#currentResult.data,\n            this.#currentQuery,\n          )\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let { error, errorUpdatedAt, fetchStatus, status } = state\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!state.dataUpdatedAt) {\n          status = 'pending'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  #updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.#trackedProps)\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.#updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","import { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\n\nfunction difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => array2.indexOf(x) === -1)\n}\n\nfunction replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = QueryObserverResult[],\n> {\n  combine?: (result: QueryObserverResult[]) => TCombinedResult\n}\n\nexport class QueriesObserver<\n  TCombinedResult = QueryObserverResult[],\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: QueryObserverResult[]\n  #queries: QueryObserverOptions[]\n  #observers: QueryObserver[]\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #combinedResult!: TCombinedResult\n\n  constructor(\n    client: QueryClient,\n    queries: QueryObserverOptions[],\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#queries = []\n    this.#observers = []\n\n    this.#setResult([])\n    this.setQueries(queries, options)\n  }\n\n  #setResult(value: QueryObserverResult[]) {\n    this.#result = value\n    this.#combinedResult = this.#combineResult(value)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#setResult(newResult)\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): TCombinedResult {\n    return this.#combinedResult\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: QueryObserverOptions[],\n  ): [\n    rawResult: QueryObserverResult[],\n    combineResult: (r?: QueryObserverResult[]) => TCombinedResult,\n    trackResult: () => QueryObserverResult[],\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: QueryObserverResult[]) => {\n        return this.#combineResult(r ?? result)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult)\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(input: QueryObserverResult[]): TCombinedResult {\n    const combine = this.#options?.combine\n    if (combine) {\n      return replaceEqualDeep(this.#combinedResult, combine(input))\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.#observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.#client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const currentObserver = this.#observers.find(\n        (o) => o.options.queryHash === defaultedOptions.queryHash,\n      )\n      return (\n        currentObserver ?? new QueryObserver(this.#client, defaultedOptions)\n      )\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options) => {\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#setResult(replaceAt(this.#result, index, result))\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.#result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  shouldDehydrateMutation?: (mutation: Mutation) => boolean\n  shouldDehydrateQuery?: (query: Query) => boolean\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const filterMutation =\n    options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation\n\n  const mutations = client\n    .getMutationCache()\n    .getAll()\n    .flatMap((mutation) =>\n      filterMutation(mutation) ? [dehydrateMutation(mutation)] : [],\n    )\n\n  const filterQuery =\n    options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery\n\n  const queries = client\n    .getQueryCache()\n    .getAll()\n    .flatMap((query) => (filterQuery(query) ? [dehydrateQuery(query)] : []))\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach((dehydratedQuery) => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n    const dehydratedQueryState = {\n      ...dehydratedQuery.state,\n      fetchStatus: 'idle' as const,\n    }\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQueryState,\n    )\n  })\n}\n","import type {\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  DefaultError,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  TData,\n  InfiniteData<TQueryData>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward' },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward' },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>, TQueryKey>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n\n    const { isFetching, isRefetching } = result\n\n    const isFetchingNextPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'forward'\n\n    const isFetchingPreviousPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'backward'\n\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n  }\n}\n","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverResult,\n  MutationObserverOptions,\n  DefaultError,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n    this.#currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(\n            action.data,\n            this.#currentResult.variables!,\n            this.#currentResult.context!,\n          )\n          this.#mutateOptions.onSettled?.(\n            action.data,\n            null,\n            this.#currentResult.variables!,\n            this.#currentResult.context,\n          )\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(\n            action.error,\n            this.#currentResult.variables!,\n            this.#currentResult.context,\n          )\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            this.#currentResult.variables!,\n            this.#currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n","import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashKey,\n  noop,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  DefaultError,\n  CancelOptions,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): TQueryFnData | undefined {\n    return this.#queryCache.find<TQueryFnData>({ queryKey })?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const cachedData = this.getQueryData<TData>(options.queryKey)\n\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(options)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(filters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.#queryCache.find<TQueryFnData>({ queryKey })\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = DefaultError>(\n    queryKey: QueryKey,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.#queryCache.find<TQueryFnData, TError>({ queryKey })?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void> {\n    const queryCache = this.#queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(\n    filters: QueryFilters = {},\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters: InvalidateQueryFilters = {},\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries(\n    filters: RefetchQueryFilters = {},\n    options?: RefetchOptions,\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData>> {\n    options.behavior = infiniteQueryBehavior<TQueryFnData, TError, TData>()\n    return this.fetchQuery(options)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.#mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: Partial<\n      Omit<QueryObserverOptions<unknown, any, any, any>, 'queryKey'>\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    let result: QueryObserverOptions<any, any, any, any, any> = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: Omit<MutationObserverOptions<any, any, any, any>, 'mutationKey'>,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    let result: MutationObserverOptions<any, any, any, any> = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options?:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...(options?.queryKey && this.getQueryDefaults(options.queryKey)),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.throwOnError === 'undefined') {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"],"names":["Subscribable","constructor","this","listeners","Set","subscribe","bind","listener","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","structuralSharing","addToEnd","items","item","newItems","slice","addToStart","focusManager","focused","cleanup","setup","super","onFocus","addEventListener","removeEventListener","setEventListener","undefined","setFocused","forEach","isFocused","globalThis","document","visibilityState","onlineManager","online","onOnline","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","didContinue","cancelRetry","continueRetry","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","gcTimeout","destroy","clearGcTimeout","scheduleGc","gcTime","optionalRemove","updateGcTime","newGcTime","clearTimeout","Query","initialState","revertState","cache","retryer","observers","defaultOptions","abortSignalConsumed","setOptions","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","shouldFetchOnReconnect","addObserver","indexOf","notify","removeObserver","filter","invalidate","fetch","fetchOptions","queryFn","abortController","AbortController","queryFnContext","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","Error","behavior","onFetch","onSettled","isFetchingOptimistic","action","reducer","onQueryUpdate","QueryCache","queries","Map","build","client","defaultQueryOptions","getQueryDefaults","has","set","queryInMap","clear","getAll","values","defaultedFilters","findAll","event","Mutation","mutationCache","mutationId","execute","variables","async","executeMutation","mutationFn","restored","onMutate","failureReason","isPaused","submittedAt","onMutationUpdate","MutationCache","mutations","resuming","defaultMutationOptions","resumePausedMutations","pausedMutations","infiniteQueryBehavior","direction","fetchMore","oldPages","pages","oldPageParams","pageParams","empty","cancelled","fetchPage","param","previous","pageParam","aborted","page","maxPages","addTo","oldData","getPreviousPageParam","getNextPageParam","defaultPageParam","lastIndex","hasNextPage","hasPreviousPage","QueryObserver","currentQuery","currentQueryInitialState","currentResult","currentResultState","currentResultOptions","selectError","selectFn","selectResult","lastQueryWithDefinedData","staleTimeoutId","refetchIntervalId","currentRefetchInterval","trackedProps","bindMethods","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","throwOnError","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","select","placeholderData","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","includedProps","typedKey","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","difference","array1","array2","dehydrateMutation","dehydrateQuery","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","fetchNextPage","fetchPreviousPage","isFetchingNextPage","isFetchingPreviousPage","currentMutation","mutateOptions","mutate","getMutationCache","isIdle","combinedResult","setResult","setQueries","combineResult","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newResult","hasIndexChange","index","getQueries","getObservers","matches","r","observerResult","input","combine","prevObserversMap","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","getObserver","newOrReusedObservers","concat","replaceAt","queryCache","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","unsubscribeOnline","mount","unmount","isMutating","getQueryData","ensureQueryData","cachedData","fetchQuery","getQueriesData","setQueryData","updater","functionalUpdate","setQueriesData","getQueryState","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","defaultedCancelOptions","promises","all","invalidateQueries","refetchType","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","defaults","queryDefault","setMutationDefaults","getMutationDefaults","_defaulted","filterMutation","shouldDehydrateMutation","filterQuery","shouldDehydrateQuery","dehydratedState","dehydratedMutation","dehydratedQuery","dehydratedQueryState","previousData"],"mappings":"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"}