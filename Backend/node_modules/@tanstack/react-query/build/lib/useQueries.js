'use client';
'use strict';

var React = require('react');
var queryCore = require('@tanstack/query-core');
var QueryClientProvider = require('./QueryClientProvider.js');
var isRestoring = require('./isRestoring.js');
var QueryErrorResetBoundary = require('./QueryErrorResetBoundary.js');
var errorBoundaryUtils = require('./errorBoundaryUtils.js');
var suspense = require('./suspense.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.
// `placeholderData` function does not have a parameter

function useQueries({
  queries,
  ...options
}, queryClient) {
  const client = QueryClientProvider.useQueryClient(queryClient);
  const isRestoring$1 = isRestoring.useIsRestoring();
  const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();
  const defaultedQueries = React__namespace.useMemo(() => queries.map(opts => {
    const defaultedOptions = client.defaultQueryOptions(opts);

    // Make sure the results are already in fetching state before subscribing or updating options
    defaultedOptions._optimisticResults = isRestoring$1 ? 'isRestoring' : 'optimistic';
    return defaultedOptions;
  }), [queries, client, isRestoring$1]);
  defaultedQueries.forEach(query => {
    suspense.ensureStaleTime(query);
    errorBoundaryUtils.ensurePreventErrorBoundaryRetry(query, errorResetBoundary);
  });
  errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = React__namespace.useState(() => new queryCore.QueriesObserver(client, defaultedQueries, options));
  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(defaultedQueries);
  React__namespace.useSyncExternalStore(React__namespace.useCallback(onStoreChange => isRestoring$1 ? () => undefined : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React__namespace.useEffect(() => {
    // Do not notify on updates because of changes in the options because
    // these changes should already be reflected in the optimistic result.
    observer.setQueries(defaultedQueries, options, {
      listeners: false
    });
  }, [defaultedQueries, options, observer]);
  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => suspense.shouldSuspend(defaultedQueries[index], result, isRestoring$1));
  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {
    const opts = defaultedQueries[index];
    const queryObserver = observer.getObservers()[index];
    if (opts && queryObserver) {
      if (suspense.shouldSuspend(opts, result, isRestoring$1)) {
        return suspense.fetchOptimistic(opts, queryObserver, errorResetBoundary);
      } else if (suspense.willFetch(result, isRestoring$1)) {
        void suspense.fetchOptimistic(opts, queryObserver, errorResetBoundary);
      }
    }
    return [];
  }) : [];
  if (suspensePromises.length > 0) {
    throw Promise.all(suspensePromises);
  }
  const observerQueries = observer.getQueries();
  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => {
    var _defaultedQueries$ind, _defaultedQueries$ind2;
    return errorBoundaryUtils.getHasError({
      result,
      errorResetBoundary,
      throwOnError: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.throwOnError) != null ? _defaultedQueries$ind : false,
      query: observerQueries[index]
    });
  });
  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {
    throw firstSingleResultWhichShouldThrow.error;
  }
  return getCombinedResult(trackResult());
}

exports.useQueries = useQueries;
//# sourceMappingURL=useQueries.js.map
