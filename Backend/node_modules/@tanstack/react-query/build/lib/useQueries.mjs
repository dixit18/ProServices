'use client';
import * as React from 'react';
import { QueriesObserver, notifyManager } from '@tanstack/query-core';
import { useQueryClient } from './QueryClientProvider.mjs';
import { useIsRestoring } from './isRestoring.mjs';
import { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';
import { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';
import { ensureStaleTime, shouldSuspend, fetchOptimistic, willFetch } from './suspense.mjs';

// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.
// `placeholderData` function does not have a parameter

function useQueries({
  queries,
  ...options
}, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedQueries = React.useMemo(() => queries.map(opts => {
    const defaultedOptions = client.defaultQueryOptions(opts);

    // Make sure the results are already in fetching state before subscribing or updating options
    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';
    return defaultedOptions;
  }), [queries, client, isRestoring]);
  defaultedQueries.forEach(query => {
    ensureStaleTime(query);
    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);
  });
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = React.useState(() => new QueriesObserver(client, defaultedQueries, options));
  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(defaultedQueries);
  React.useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React.useEffect(() => {
    // Do not notify on updates because of changes in the options because
    // these changes should already be reflected in the optimistic result.
    observer.setQueries(defaultedQueries, options, {
      listeners: false
    });
  }, [defaultedQueries, options, observer]);
  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => shouldSuspend(defaultedQueries[index], result, isRestoring));
  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {
    const opts = defaultedQueries[index];
    const queryObserver = observer.getObservers()[index];
    if (opts && queryObserver) {
      if (shouldSuspend(opts, result, isRestoring)) {
        return fetchOptimistic(opts, queryObserver, errorResetBoundary);
      } else if (willFetch(result, isRestoring)) {
        void fetchOptimistic(opts, queryObserver, errorResetBoundary);
      }
    }
    return [];
  }) : [];
  if (suspensePromises.length > 0) {
    throw Promise.all(suspensePromises);
  }
  const observerQueries = observer.getQueries();
  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedQueries[index]?.throwOnError ?? false,
    query: observerQueries[index]
  }));
  if (firstSingleResultWhichShouldThrow?.error) {
    throw firstSingleResultWhichShouldThrow.error;
  }
  return getCombinedResult(trackResult());
}

export { useQueries };
//# sourceMappingURL=useQueries.mjs.map
