{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/subscribable.mjs","../../../query-core/build/lib/utils.mjs","../../../query-core/build/lib/focusManager.mjs","../../../query-core/build/lib/onlineManager.mjs","../../../query-core/build/lib/retryer.mjs","../../../query-core/build/lib/notifyManager.mjs","../../../query-core/build/lib/removable.mjs","../../../query-core/build/lib/query.mjs","../../../query-core/build/lib/queryCache.mjs","../../../query-core/build/lib/mutation.mjs","../../../query-core/build/lib/mutationCache.mjs","../../../query-core/build/lib/infiniteQueryBehavior.mjs","../../../query-core/build/lib/queryObserver.mjs","../../../query-core/build/lib/queriesObserver.mjs","../../../query-core/build/lib/infiniteQueryObserver.mjs","../../../query-core/build/lib/mutationObserver.mjs","../../../query-core/build/lib/hydration.mjs","../../src/QueryClientProvider.tsx","../../src/isRestoring.tsx","../../src/QueryErrorResetBoundary.tsx","../../src/utils.ts","../../src/errorBoundaryUtils.ts","../../src/suspense.ts","../../src/useBaseQuery.ts","../../src/useMutationState.ts","../../src/useMutation.ts","../../src/HydrationBoundary.tsx","../../../query-core/build/lib/queryClient.mjs","../../src/useQuery.ts","../../src/useInfiniteQuery.ts","../../src/useIsFetching.ts","../../src/useQueries.ts"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n    // Do nothing\n  }\n  onUnsubscribe() {\n    // Do nothing\n  }\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n\n// UTILS\n\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== 'all') {\n    const isActive = query.isActive();\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    status,\n    predicate,\n    mutationKey\n  } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nfunction hashKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\n\nexport { addToEnd, addToStart, functionalUpdate, hashKey, hashQueryKeyByOptions, isPlainArray, isPlainObject, isServer, isValidTimeout, keepPreviousData, matchMutation, matchQuery, noop, partialMatchKey, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = undefined;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    this.#focused = focused;\n    if (focused) {\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused;\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden';\n  }\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass OnlineManager extends Subscribable {\n  #online;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline();\n        // Listen to online\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = undefined;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n  setOnline(online) {\n    this.#online = online;\n    if (online) {\n      this.onOnline();\n    }\n  }\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n  isOnline() {\n    if (typeof this.#online === 'boolean') {\n      return this.#online;\n    }\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n    return navigator.onLine;\n  }\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      promiseResolve(value);\n    }\n  };\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n        if (canContinue) {\n          continueResolve(value);\n        }\n        return canContinue;\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = undefined;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      }\n\n      // Do we need to retry the request?\n      const retry = config.retry ?? 3;\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n      failureCount++;\n\n      // Notify on fail\n      config.onFail?.(failureCount, error);\n\n      // Delay\n      sleep(delay)\n      // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\n// TYPES\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = callback => {\n    callback();\n  };\n  let batchNotifyFn = callback => {\n    callback();\n  };\n  const batch = callback => {\n    let result;\n    transactions++;\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n      if (!transactions) {\n        flush();\n      }\n    }\n    return result;\n  };\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n}\n\n// SINGLETON\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(this.gcTime || 0, newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000));\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = undefined;\n    }\n  }\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// TYPES\n\n// CLASS\n\nclass Query extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #promise;\n  #retryer;\n  #observers;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.#setOptions(config.options);\n    this.#observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = config.state || getDefaultState(this.options);\n    this.state = this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  #setOptions(options) {\n    this.options = {\n      ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    const promise = this.#promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.#observers.some(observer => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#observers.some(observer => observer.getCurrentResult().isStale);\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.#observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.#observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (this.#observers.indexOf(observer) === -1) {\n      this.#observers.push(observer);\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.#observers.indexOf(observer) !== -1) {\n      this.#observers = this.#observers.filter(x => x !== observer);\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.#observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.#promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer?.continueRetry();\n        // Return current promise if we are already fetching\n        return this.#promise;\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.#setOptions(options);\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.#setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n      }\n    }\n    const abortController = new AbortController();\n\n    // Create query function context\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext);\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(new Error('Missing queryFn'));\n      }\n      this.#abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    };\n\n    // Trigger behavior hook\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(context);\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state;\n\n    // Set to fetching state if not already in it\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({\n        type: 'fetch',\n        meta: context.fetchOptions?.meta\n      });\n    }\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(error, this);\n        this.#cache.config.onSettled?.(this.state.data, error, this);\n      }\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: data => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        this.setData(data);\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(data, this.state.error, this);\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.#dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.#dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.#promise = this.#retryer.promise;\n    return this.#promise;\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused'\n          };\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching'\n          };\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'pending'\n            })\n          };\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n        case 'error':\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return {\n              ...this.#revertState\n            };\n          }\n          return {\n            ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case 'setState':\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\n\nclass QueryCache extends Subscribable {\n  #queries;\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = new Map();\n  }\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(query => matchQuery(defaultedFilters, query));\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter(query => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// TYPES\n\n// CLASS\n\nclass Mutation extends Removable {\n  #observers;\n  #defaultOptions;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#defaultOptions = config.defaultOptions;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = {\n      ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (this.#observers.indexOf(observer) === -1) {\n      this.#observers.push(observer);\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ??\n    // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    const executeMutation = () => {\n      this.#retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject(new Error('No mutationFn found'));\n          }\n          return this.options.mutationFn(variables);\n        },\n        onFail: (failureCount, error) => {\n          this.#dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.#dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.#dispatch({\n            type: 'continue'\n          });\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.#retryer.promise;\n    };\n    const restored = this.state.status === 'pending';\n    try {\n      if (!restored) {\n        this.#dispatch({\n          type: 'pending',\n          variables\n        });\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(variables, this);\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables\n          });\n        }\n      }\n      const data = await executeMutation();\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(data, variables, this.state.context, this);\n      await this.options.onSuccess?.(data, variables, this.state.context);\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(data, null, this.state.variables, this.state.context, this);\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(error, variables, this.state.context, this);\n        await this.options.onError?.(error, variables, this.state.context);\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(undefined, error, this.state.variables, this.state.context, this);\n        await this.options.onSettled?.(undefined, error, variables, this.state.context);\n        throw error;\n      } finally {\n        this.#dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true\n          };\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false\n          };\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// TYPES\n\n// CLASS\n\nclass MutationCache extends Subscribable {\n  #mutations;\n  #mutationId;\n  #resuming;\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = [];\n    this.#mutationId = 0;\n  }\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n  remove(mutation) {\n    this.#mutations = this.#mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return this.#mutations;\n  }\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.#mutations.find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n  findAll(filters = {}) {\n    return this.#mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    this.#resuming = (this.#resuming ?? Promise.resolve()).then(() => {\n      const pausedMutations = this.#mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.#resuming = undefined;\n    });\n    return this.#resuming;\n  }\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","import { addToStart, addToEnd } from './utils.mjs';\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = {\n          pages: [],\n          pageParams: []\n        };\n        let cancelled = false;\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n\n        // Get query function\n        const queryFn = context.options.queryFn || (() => Promise.reject(new Error('Missing queryFn')));\n\n        // Create function to fetch a page\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (typeof param === 'undefined' && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          result = await fetchPage(empty, options.defaultPageParam);\n        }\n\n        // fetch next / previous page?\n        else if (direction) {\n          const previous = direction === 'backward';\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        }\n\n        // Refetch pages\n        else {\n          // Fetch first page\n          result = await fetchPage(empty, oldPageParams[0]);\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, {\n  pages,\n  pageParams\n}) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\nfunction getPreviousPageParam(options, {\n  pages,\n  pageParams\n}) {\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);\n}\n\n/**\n * Checks if there is a next page.\n */\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return typeof getNextPageParam(options, data) !== 'undefined';\n}\n\n/**\n * Checks if there is a previous page.\n */\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return typeof getPreviousPageParam(options, data) !== 'undefined';\n}\n\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  #client;\n  #currentQuery = undefined;\n  #currentQueryInitialState = undefined;\n  #currentResult = undefined;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = new Set();\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.options = options;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n  destroy() {\n    this.listeners = new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n    this.#updateQuery();\n    const mounted = this.hasListeners();\n\n    // Fetch if there are subscribers\n    if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {\n      this.#executeFetch();\n    }\n\n    // Update result\n    this.#updateResult(notifyOptions);\n\n    // Update stale interval if needed\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n\n    // Update refetch interval if needed\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    return this.createResult(query, options);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({\n    ...options\n  } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.#updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery();\n\n    // Fetch\n    let promise = this.#currentQuery.fetch(this.options, fetchOptions);\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, this.options.staleTime);\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.#updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.#currentResult.data, this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = undefined;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = undefined;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const {\n      state\n    } = query;\n    let {\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPlaceholderData = false;\n    let data;\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n        if (!state.dataUpdatedAt) {\n          status = 'pending';\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data;\n    }\n\n    // Show placeholder data if needed\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'pending') {\n      let placeholderData;\n\n      // Memoize placeholder data\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options.placeholderData;\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult?.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n    const isFetching = fetchStatus === 'fetching';\n    const isPending = status === 'pending';\n    const isError = status === 'error';\n    const isLoading = isPending && isFetching;\n    const result = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  #updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    this.#currentResult = nextResult;\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(notifyOnChangeProps ?? this.#trackedProps);\n      if (this.options.throwOnError) {\n        includedProps.add('error');\n      }\n      return Object.keys(this.#currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({\n      ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.#updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.#currentResult);\n        });\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated'\n      });\n    });\n  }\n}\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { replaceEqualDeep } from './utils.mjs';\n\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nclass QueriesObserver extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #observers;\n  #options;\n  #combinedResult;\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#queries = [];\n    this.#observers = [];\n    this.#setResult([]);\n    this.setQueries(queries, options);\n  }\n  #setResult(value) {\n    this.#result = value;\n    this.#combinedResult = this.#combineResult(value);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = new Set();\n    this.#observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options, notifyOptions) {\n    this.#queries = queries;\n    this.#options = options;\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.#observers = newObservers;\n      this.#setResult(newResult);\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#combinedResult;\n  }\n  getQueries() {\n    return this.#observers.map(observer => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n    return [result, r => {\n      return this.#combineResult(r ?? result);\n    }, () => {\n      return matches.map((match, index) => {\n        const observerResult = result[index];\n        return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult) : observerResult;\n      });\n    }];\n  }\n  #combineResult(input) {\n    const combine = this.#options?.combine;\n    if (combine) {\n      return replaceEqualDeep(this.#combinedResult, combine(input));\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObservers = this.#observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.#client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const getObserver = options => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const currentObserver = this.#observers.find(o => o.options.queryHash === defaultedOptions.queryHash);\n      return currentObserver ?? new QueryObserver(this.#client, defaultedOptions);\n    };\n    const newOrReusedObservers = unmatchedQueries.map(options => {\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#setResult(replaceAt(this.#result, index, result));\n      this.#notify();\n    }\n  }\n  #notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.#result);\n      });\n    });\n  }\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n\n  // Type override\n\n  // Type override\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options, notifyOptions) {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward'\n        }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward'\n        }\n      }\n    });\n  }\n  createResult(query, options) {\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && state.fetchMeta?.fetchMore?.direction === 'forward';\n    const isFetchingPreviousPage = isFetching && state.fetchMeta?.fetchMore?.direction === 'backward';\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// TYPES\n\n// CLASS\n\nclass MutationObserver extends Subscribable {\n  #client;\n  #currentResult = undefined;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    this.#currentMutation?.setOptions(this.options);\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation = undefined;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? getDefaultState();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, this.#currentResult.variables, this.#currentResult.context);\n          this.#mutateOptions.onSettled?.(action.data, null, this.#currentResult.variables, this.#currentResult.context);\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, this.#currentResult.variables, this.#currentResult.context);\n          this.#mutateOptions.onSettled?.(undefined, action.error, this.#currentResult.variables, this.#currentResult.context);\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach(listener => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","// TYPES\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(mutation => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []);\n  const filterQuery = options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const queries = client.getQueryCache().getAll().flatMap(query => filterQuery(query) ? [dehydrateQuery(query)] : []);\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = dehydratedState.mutations || [];\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(client, {\n      ...options?.defaultOptions?.mutations,\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash);\n\n    // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n    const dehydratedQueryState = {\n      ...dehydratedQuery.state,\n      fetchStatus: 'idle'\n    };\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState);\n      }\n      return;\n    }\n\n    // Restore query\n    queryCache.build(client, {\n      ...options?.defaultOptions?.queries,\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQueryState);\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  throwError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwError function to override throwing behavior on a per-error basis\n  if (typeof throwError === 'function') {\n    return throwError(...params)\n  }\n\n  return !!throwError\n}\n","'use client'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.throwOnError) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(throwOnError, [result.error, query])\n  )\n}\n","import type {\n  DefaultedQueryObserverOptions,\n  QueryObserverResult,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient, QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport * as React from 'react'\n\nimport type {\n  MutationFilters,\n  QueryClient,\n  Mutation,\n  MutationCache,\n  DefaultError,\n  MutationState,\n} from '@tanstack/query-core'\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>,\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>,\n            )\n          : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>()\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n","'use client'\nimport * as React from 'react'\nimport type { QueryClient, DefaultError } from '@tanstack/query-core'\nimport { notifyManager, MutationObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","'use client'\nimport * as React from 'react'\n\nimport type { HydrateOptions, QueryClient } from '@tanstack/query-core'\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(client, state, optionsRef.current)\n    }\n  }, [client, state])\n\n  return children as React.ReactElement\n}\n","import { functionalUpdate, noop, hashKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\n\n// TYPES\n\n// CLASS\n\nclass QueryClient {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = new Map();\n    this.#mutationDefaults = new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = undefined;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = undefined;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({\n      ...filters,\n      fetchStatus: 'fetching'\n    }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({\n      ...filters,\n      status: 'pending'\n    }).length;\n  }\n  getQueryData(queryKey) {\n    return this.#queryCache.find({\n      queryKey\n    })?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(options);\n  }\n  getQueriesData(filters) {\n    return this.getQueryCache().findAll(filters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const query = this.#queryCache.find({\n      queryKey\n    });\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n    const defaultedOptions = this.defaultQueryOptions({\n      queryKey\n    });\n    return this.#queryCache.build(this, defaultedOptions).setData(data, {\n      ...options,\n      manual: true\n    });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(filters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n  getQueryState(queryKey) {\n    return this.#queryCache.find({\n      queryKey\n    })?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters = {}, cancelOptions = {}) {\n    const defaultedCancelOptions = {\n      revert: true,\n      ...cancelOptions\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).map(query => query.cancel(defaultedCancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters = {}, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters = {}, options) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      let promise = query.fetch(undefined, fetchOptions);\n      if (!fetchOptions.throwOnError) {\n        promise = promise.catch(noop);\n      }\n      return query.state.fetchStatus === 'paused' ? Promise.resolve() : promise;\n    }));\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  resumePausedMutations() {\n    return this.#mutationCache.resumePausedMutations();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = {\n          ...result,\n          ...queryDefault.defaultOptions\n        };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = {\n          ...result,\n          ...queryDefault.defaultOptions\n        };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...(options?.queryKey && this.getQueryDefaults(options.queryKey)),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n    if (typeof defaultedOptions.throwOnError === 'undefined') {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey && this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","'use client'\nimport type { QueryClient, QueryKey, DefaultError } from '@tanstack/query-core'\nimport { QueryObserver } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n\n// HOOK\ntype UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?: undefined\n}\n\ntype DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData: TQueryFnData | (() => TQueryFnData)\n}\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n","'use client'\nimport type {\n  QueryObserver,\n  QueryKey,\n  QueryClient,\n  DefaultError,\n  InfiniteData,\n} from '@tanstack/query-core'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    options,\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","'use client'\nimport * as React from 'react'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nimport type {\n  QueryKey,\n  QueryFunction,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  DefaultError,\n  QueriesObserverOptions,\n} from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, Error, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, Error, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<\n      unknown extends TData ? TQueryFnData : TData,\n      unknown extends TError ? DefaultError : TError\n    >[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<\n  T extends any[],\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(opts)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(defaultedQueries)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (opts && queryObserver) {\n          if (shouldSuspend(opts, result, isRestoring)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedQueries[index]?.throwOnError ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"names":["Subscribable","constructor","this","listeners","Set","subscribe","bind","listener","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","structuralSharing","addToEnd","items","item","newItems","slice","addToStart","focusManager","focused","cleanup","setup","super","onFocus","addEventListener","removeEventListener","setEventListener","undefined","setFocused","forEach","isFocused","globalThis","document","visibilityState","onlineManager","online","onOnline","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","didContinue","cancelRetry","continueRetry","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","gcTimeout","destroy","clearGcTimeout","scheduleGc","gcTime","optionalRemove","updateGcTime","newGcTime","clearTimeout","Query","initialState","revertState","cache","retryer","observers","defaultOptions","abortSignalConsumed","setOptions","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","shouldFetchOnReconnect","addObserver","indexOf","notify","removeObserver","filter","invalidate","fetch","fetchOptions","queryFn","abortController","AbortController","queryFnContext","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","Error","behavior","onFetch","onSettled","isFetchingOptimistic","action","reducer","onQueryUpdate","QueryCache","queries","Map","build","client","defaultQueryOptions","getQueryDefaults","has","set","queryInMap","clear","getAll","values","defaultedFilters","findAll","event","Mutation","mutationCache","mutationId","execute","variables","async","executeMutation","mutationFn","restored","onMutate","failureReason","isPaused","submittedAt","onMutationUpdate","MutationCache","mutations","resuming","defaultMutationOptions","resumePausedMutations","pausedMutations","infiniteQueryBehavior","direction","fetchMore","oldPages","pages","oldPageParams","pageParams","empty","cancelled","fetchPage","param","previous","pageParam","aborted","page","maxPages","addTo","oldData","getPreviousPageParam","getNextPageParam","defaultPageParam","lastIndex","hasNextPage","hasPreviousPage","QueryObserver","currentQuery","currentQueryInitialState","currentResult","currentResultState","currentResultOptions","selectError","selectFn","selectResult","lastQueryWithDefinedData","staleTimeoutId","refetchIntervalId","currentRefetchInterval","trackedProps","bindMethods","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","throwOnError","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","select","placeholderData","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","includedProps","typedKey","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","difference","array1","array2","QueriesObserver","combinedResult","setResult","setQueries","combineResult","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newResult","hasIndexChange","index","getQueries","getObservers","matches","r","observerResult","input","combine","prevObserversMap","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","getObserver","newOrReusedObservers","concat","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","isFetchingNextPage","isFetchingPreviousPage","MutationObserver","currentMutation","mutateOptions","mutate","getMutationCache","isIdle","dehydrateMutation","dehydrateQuery","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","hydrate","dehydratedState","queryCache","dehydratedMutation","dehydratedQuery","dehydratedQueryState","QueryClientContext","React","createContext","useQueryClient","queryClient","useContext","IsRestoringContext","useIsRestoring","IsRestoringProvider","Provider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","throwError","params","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","useEffect","getHasError","ensureStaleTime","willFetch","isRestoring","shouldSuspend","useBaseQuery","Observer","useState","useSyncExternalStore","useCallback","onStoreChange","getResult","useMutationState","optionsRef","useRef","current","children","useMemo","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","unsubscribeOnline","mount","unmount","isMutating","getQueryData","ensureQueryData","cachedData","fetchQuery","getQueriesData","setQueryData","updater","functionalUpdate","setQueriesData","getQueryState","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","defaultedCancelOptions","promises","all","invalidateQueries","refetchType","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","defaults","queryDefault","setMutationDefaults","getMutationDefaults","_defaulted","createElement","filterMutation","shouldDehydrateMutation","filterQuery","shouldDehydrateQuery","previousData","mutateAsync","defaultedQueries","opts","optimisticResult","getCombinedResult","suspensePromises","queryObserver","observerQueries","firstSingleResultWhichShouldThrow"],"mappings":"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"}